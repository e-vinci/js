---
title: "RESTful API"
description: "Introduction aux RESTful API en Node.js & Express"
---

# a) Introduction aux RESTful API en Node.js & Express

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part1"> Partie 1 </PathViewerItem>
    <PathViewerItem selected> a) RESTful API </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Introduction aux RESTful API & conventions </InternalPageMenuItem>
  <InternalPageMenuItem> Configuration & d√©marrage d'une RESTful API en Express </InternalPageMenuItem>
  <InternalPageMenuItem> Les fonctions middleware en Express </InternalPageMenuItem>
  <InternalPageMenuItem> D√©finition d'une route en Express </InternalPageMenuItem>
  <InternalPageMenuItem> Op√©rations de lecture </InternalPageMenuItem> 
  <InternalPageMenuItem> Exercice 1.1 : lecture de toutes les ressources </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 1.2 : middleware s'ex√©cutant sur toutes les routes </InternalPageMenuItem>
  <InternalPageMenuItem> Param√®tres de route </InternalPageMenuItem>
  <InternalPageMenuItem> Param√®tres de requ√™te </InternalPageMenuItem>
  <InternalPageMenuItem> Op√©ration de cr√©ation & parsing du body </InternalPageMenuItem>
  <InternalPageMenuItem> Client REST </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 1.3 : lectures sp√©cifiques, cr√©ation & REST Client </InternalPageMenuItem>
  <InternalPageMenuItem> üç¨ Exercice 1.4 : Gestion de la pagination, du tri et du filtrage </InternalPageMenuItem>
  <InternalPageMenuItem> Codes de statut HTTP associ√©s aux r√©ponses </InternalPageMenuItem> 
  <InternalPageMenuItem> Exercice 1.5 : codes de statut HTTP </InternalPageMenuItem>
  <InternalPageMenuItem> Op√©rations de suppression & de modification </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 1.6 : suppression & modification de ressources </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> Introduction aux RESTful API & conventions </InternalPageTitle>
## C'est quoi une application REST ?

<div className="card card__simple-youtube-container">
    <YoutubeImage src="https://youtu.be/EIESrlEV-CQ" />
</div>

**REST** vient de **RE**presentational **S**tate **T**ransfer : c'est un style architectural pour construire des applications web extensibles, o√π les client et serveurs sont s√©par√©s.

Dans une application REST, une **interface uniforme** (ou API) est d√©finie afin de permettre √† des applications de coop√©rer.

Toute application REST se doit d'√™tre **stateless** : il n'y a pas d'enregistrement du contexte d'une session sur le serveur pour comprendre une requ√™te d'un client.  
Ainsi, les requ√™tes clientes ne d√©pendent pas d'un historique de requ√™tes, chaque requ√™te contient tout l'information n√©cessaire au serveur.

Une RESTful API met √† disposition des **op√©rations** sur des **ressources** via :
- des **URI** ; il y a donc une adresse unique pur chaque ressource ;
- des **m√©thodes HTTP** (GET, POST, DELETE, PATCH, PUT) repr√©sentant les op√©rations possibles ; on parle souvent d'op√©rations **CRUD**, des op√©rations de type **C**reate, **R**ead, **U**pdate ou **D**elete) ;
- des **repr√©sentations** des ressources compr√©hensibles tant par les clients que les serveurs ; les ressources sont repr√©sent√©es par leur "Media type" : **JSON**, **XML**, **HTML**, **TXT**, **JPEG**... ; dans le cadre de ce cours, les ressources seront quasi toujours repr√©sent√©es via du **JSON**.

## Conventions REST

 Le type d'op√©ration CRUD sur une ressource est d√©fini via la **m√©thode http** de la requ√™te.  
 Les op√©rations possibles sont :
  - GET = Read
  - POST = Create
  - DELETE = Delete üòâ
  - PATCH / PUT = Update
    - PATCH = Update d'une ou plusieurs propri√©t√©(s) de la ressources
    - PUT = Update de toutes les propri√©t√©s de la ressources, ou cr√©ation si la ressource n'existe pas
    
Voici un exemple d'application de ces conventions REST dans le cadre d'une RESTful API permettant de g√©rer des **posts** :

| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **`posts`** | GET | READ ALL : Lire toutes les ressources de la collection |
| **`posts?userId=value`** | GET | READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donn√© |
| **`posts/{id}`** | GET | READ ONE : Lire la ressource identifi√©e |
| **`posts`** | POST | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| **`posts/{id}`** | DELETE | DELETE ONE : Effacer la ressource identifi√©e |
| **`posts/{id}`** | PUT | UPDATE ONE : Remplacer l'enti√®ret√© de la ressource par les donn√©es de la requ√™te |

<br/>

Lors de l'ajout d'un post, si cette API est h√©berg√©e √† l'URL racine **https://jsonplaceholder.typicode.com/**, alors nous pourrions identifier une ressource de type **posts** de cette fa√ßon : **https://jsonplaceholder.typicode.com/posts/10**.

Pour lire cette ressource, il faudrait faire une requ√™te http de type **GET** sur cette **URL** : **https://jsonplaceholder.typicode.com/posts/10**.

# <InternalPageTitle> Configuration & d√©marrage d'une RESTful API en Express </InternalPageTitle>

<div className="card card__simple-youtube-container">
    <YoutubeImage src="https://youtu.be/pnf0FDNvkto" />
</div>

## Cr√©ation d'un projet
Nous allons maintenant cr√©er notre toute premi√®re RESTful API pour g√©rer les donn√©es associ√©es √† une pizzeria, afin de b√©n√©ficier d'op√©rations sur des ressources de type "pizzas".

Dans votre repo **web2**, veuillez cr√©er le r√©pertoire **`/tutorials/pizzeria/api`**.

Veuillez ouvrir un terminal au niveau de ce r√©pertoire.

Dans ce r√©pertoire, veuillez g√©n√©rer une application express nomm√©e **basic**.  
Pour ce faire :

```bash
npx express-generator --no-view basic
```

Veuillez installer les d√©pendances :
```bash
cd basic
npm i
```

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire **`/tutorials/pizzeria/api/basic`** (ou **`/web2/tutorials/pizzeria/api/basic`** si l'on consid√®re le nom du r√©pertoire du repo).

Nous allons d√©velopper des RESTful API qui ne poss√®dent pas de serveur de fichiers statiques.  
On n'a donc pas besoin d'avoir un r√©pertoire **`/public`** ni d'un serveur statique.  
On peut donc effacer le r√©pertoire **`/public`** et supprimer le middleware de serveur de fichiers statiques au sein de **`/app.js`** (en supprimant cette ligne) : 

```js
app.use(express.static(path.join(__dirname, 'public'))); 
```

## Fonctionnement d'une application Express

Nous allons maintenant nous attarder √† comprendre les concepts associ√©s √† l'utilisation d'Express, mais en focalisant sur ceux utiles aux applications REST.  
Voici comment une requ√™te faite √† une application Express est trait√©e :

<ScrollableImage name="express-flow.png" minWidth="800px" maxWidth="800px" />

<figcaption>Flux d'une requ√™te vers une application Express [R.51]</figcaption>

Dans ce flux de traitement d'une requ√™te, la responsabilit√© des d√©veloppeurs est de s'occuper de la partie "Middleware".

La grande majorit√© du code √©crit sera du "routing middleware" : notre code s'occupera de r√©pondre √† des requ√™tes clientes pour diff√©rentes URLs et m√©thodes HTTP (GET, POST...).

On l'a d√©j√† vu, la configuration d'une application Express, comme toutes applications Node.js, est faite au sein de **`package.json`**.

En fonction de comment est configur√© l'application, on la d√©marrera via **`npm start`**, **`npm run dev`**, **`npm run build`**...

Un **serveur web int√©gr√©** √† nos applications Express est d√©marr√© au sein du fichier **`bin/www`**.

C'est ce fichier que vous devez mettre √† jour si par exemple vous souhaitez que votre application fonctionne sur un port diff√©rent que le port par d√©faut **3000**.

Un serveur int√©gr√© est diff√©rent d'une application web offerte par un serveur standalone comme Apache, Tomcat... C'est un serveur tr√®s l√©ger d√©di√© √† votre application.

# <InternalPageTitle> Les fonctions middleware en Express </InternalPageTitle>
## C'est quoi une fonction middleware ?

Les fonctions middleware s'occupent du traitement des requ√™tes des clients et de la pr√©paration des r√©ponses :

<ScrollableImage name="middlewares.jpg" minWidth="638px" maxWidth="638px" />

<figcaption>Les fonctions Middleware et Express [R.52]</figcaption>

Une fonction middleware a acc√®s aux objets de la requ√™te et de la r√©ponse et peut utiliser la requ√™te et la r√©ponse pour ajouter, par exemple, un log, pour autoriser un utilisateur, pour parser des donn√©es Json vers des objets JS, pour servir des fichiers statiques, pour faire un traitement pour une route bien sp√©cifique...

Lors de l'ajout d'un film, si une fonction middleware ne termine pas le cycle de requ√™te-r√©ponse, elle doit appeler **`next()`** pour permettre √† d'autres fonctions qui sont dans la queue de pouvoir √™tre ex√©cut√©es.

Voici les √©l√©ments associ√©s √† l'appel d'une fonction middleware :

<ScrollableImage name="middleware-function.png" minWidth="944px" maxWidth="944px" />

<figcaption>Une fonction middleware [R.53]</figcaption>

Il existe diff√©rents types de fonctions middleware ayant diff√©rents cas d'utilisation :
- **Application-level middleware** : la fonction middleware est li√©e √† l'objet **app** et peut s'appliquer √† toutes les requ√™tes.
- **Router-level middleware** : la fonction middleware est li√©e √† un objet de type **`express.router()`** et est tr√®s similaire au "application-level middleware", mais ne s'applique qu'√† un groupe de requ√™tes.
- **Error-handling middleware** : fonction de gestion des erreurs qui se d√©finit comme les fonctions ci-dessus (au niveau **app** ou **router**), mais qui contient un quatri√®me param√®tre nomm√© **error**.
- **Built-in middleware** : fonctions middleware mises √† disposition par Express directement. En voici quelques exemples :
  - **express.static** : pour servir des assets statiques ;
  - **express.json** : pour parser le body de requ√™tes en JSON vers des objets JS ;
  - **express.urlencoded** : pour parser des requ√™tes dont le body est de type "urlencoded" (type par d√©faut des formulaires) vers des objets JS.
- **Third-party middleware** : fonctions mises √† disposition par la communaut√© et installables via npm, comme par exemple la fonction middleware **cookieParser**.

La suite fournit quelques exemples de fonctions middleware qui seront soit plus tard rencontr√©es dans notre code, soit sont extraites de la documentation d'Express : [Using middleware](https://expressjs.com/en/guide/using-middleware.html) [[R.54]](/references/#r54).

## Application-level middleware : exemple
Voici une fonction middleware qui sera ex√©cut√©e √† chaque fois qu'il y a une requ√™te, quelque soit le chemin (ou path) associ√© √† la requ√™te :

```js
var¬†express¬†=¬†require('express');
var¬†app¬†=¬†express();
app.use((req,¬†res,¬†next) =>¬†{
¬†¬†console.log('Time:',¬†Date.now());
¬†¬†next();
});
```

## Router-level middleware : exemple
Voici une partie du code qui se trouverait au sein d'un router de pizzas, dans le fichier **/routes/pizzas.js** :

```js
var¬†router¬†=¬†express.Router();

router.use((req,¬†res,¬†next)¬†=> {
¬†¬†console.log('Time:',¬†Date.now());
¬†¬†next();
});

router.get('/',(req,¬†res,¬†next)¬†=> {
¬†¬†return¬†res.json(menu);
});
```

La premi√®re fonction middleware ne contient pas de m√©thode HTTP, ni de chemin, elle s'applique donc √† toutes les routes associ√©es au router de pizzas.  
Voici le code qui permettrait, dans **/app.js**, d'appeler le router de pizzas :

```js
var pizzaRouter = require('./routes/pizzas');
app.use('/pizzas', pizzaRouter);
```

Lors de l'ajout d'un film, si le router est utilis√© de cette fa√ßon, en relisant l'avant-dernier snippet, on voit que : 
- la premi√®re fonction (o√π il y a un `console.log`) s'applique donc √† toutes les routes qui commencent par **/pizzas** ;
- la deuxi√®me fonction middleware s'appliquent seulement aux requ√™tes de type **GET** sur la route (ou le chemin) **/pizzas** (√©quivalent de la route **/pizzas/**).

## Error-handling middleware : exemple
Ce type de middleware est √† d√©finir apr√®s tous les middlewares pouvant g√©n√©rer une erreur et est appel√© via **`next(err)`** dans une fonction middleware o√π un souci est d√©tect√©.

Voici la d√©finition d'un gestionnaire d'erreurs :

```js
app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).send('Something broke!')
});
```

Attention, il y a bien 4 param√®tres au lieu des 3 habituels pour les autres types de fonctions middleware.

## Built-in middleware & third-party middleware : exemple
Dans **app.js**, on trouve pas mal d'exemples de ces types de middleware. Ils sont comment√©s ci-dessous dans le code :

```js
var express = require('express');
var path = require('path');
var cookieParser = require('cookie-parser');
var logger = require('morgan');

var app = express();

app.use(logger('dev')); //¬†HTTP request logger
app.use(express.json()); //¬†Parse requests with JSON payloads
app.use(express.urlencoded({ extended: false })); //¬†Parse requests with URL-
                                                  // encoded payload 
app.use(cookieParser()); //¬†Parse cookie header (req.cookies)
app.use(express.static(path.join(__dirname, 'public'))); //¬†Serve static assets
```

# <InternalPageTitle> D√©finition d'une route en Express </InternalPageTitle>
## D√©finition d'une route
Le routing, ou routage, contr√¥le la r√©ponse √† une requ√™te client pour un chemin et une m√©thode HTTP. Le chemin est aussi appel√© **endpoint** ou **URI** ou **PATH**.

On va d√©finir une route soit sur l'objet **app**, soit sur un **router**.  
Un objet de type **router** permet de regrouper toutes les routes associ√©es √† un type de ressources.

On d√©finit une route de cette fa√ßon : **`app.`** ou **`router.`**  **`METHOD(PATH, MIDDLEWARE_FUNCTION)`**.

üëç Dans notre cours, nous vous recommandons d'organiser vos routes par type de ressources et donc de mettre en place des routers.

# <InternalPageTitle> Op√©rations de lecture </InternalPageTitle>

<div className="card card__simple-youtube-container">
    <YoutubeImage src="https://youtu.be/VrXEj8QhFcw" />
</div>

Nous souhaitons par commencer √† d√©velopper une op√©ration permettant de lire toutes les ressources de type "pizzas".  
Veuillez cr√©er un router pour traiter des ressources **/pizzas** au sein de **`/routes/pizzas.js`**.  
Le plus simple est d'adapter **`indexRouter`** dans **`app.js`** en **`pizzaRouter`** et **`/routers/index.js`** en **`/routes/pizzas.js`**.  
NB : Il est aussi possible de partir de rien et de cr√©er **`pizzaRouter`** dans **`app.js`** et **`/routes/pizzas.js`**.

Pour l'op√©ration de lecture de toutes les pizzas, selon les conventions REST, il faut faire une requ√™te de type **`GET /pizzas`**. Le router de **`/routes/pizzas.js`** doit donc offrir une route renvoyant toutes les pizzas qui existent dans le menu.

Pour d√©marrer, nous souhaitons une application basique qui ne g√®re pas la persistance des donn√©es. Le menu sera donc un array d'objets, chaque objet repr√©sentant une pizza.

Notre op√©ration de lecture de pizza va renvoyer du JSON au client, c'est √† dire une repr√©sentation textuelle d'un array d'objets. Nous verrons plus tard ce qu'est r√©ellement le JSON. A ce stade-ci, il est suffisant de conna√Ætre la fonction d'Express qui permet √† un objet JS de circuler sur le r√©seau : **`res.json()`**.

Voici le code du router **`/routes/pizzas.js`** :
```js
var express = require('express');
var router = express.Router();

const MENU = [
  {
    id: 1,
    title: '4 fromages',
    content: 'Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates',
  },
  {
    id: 2,
    title: 'Vegan',
    content: 'Tomates, Courgettes, Oignons, Aubergines, Poivrons',
  },
  {
    id: 3,
    title: 'Vegetarian',
    content: 'Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives',
  },
  {
    id: 4,
    title: 'Alpage',
    content: 'Gruy√®re, Mozarella, Lardons, Tomates',
  },
  {
    id: 5,
    title: 'Diable',
    content: 'Tomates, Mozarella, Chorizo piquant, Jalapenos',
  },
];

// Read all the pizzas from the menu
router.get('/', (req, res, next) => {
  console.log('GET /pizzas');
  res.json(MENU);
});

module.exports = router;
```

Et voici le code de **app.js** (les parties modifi√©es sont surlign√©es) :

```js numbered highlighting="6,16"
var express = require('express');
var path = require('path');
var cookieParser = require('cookie-parser');
var logger = require('morgan');

var pizzaRouter = require('./routes/pizzas');
var usersRouter = require('./routes/users');

var app = express();

app.use(logger('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());

app.use('/pizzas', pizzaRouter);
app.use('/users', usersRouter);

module.exports = app;
```

Veuillez d√©marrer l'API (par d√©faut elle est configur√©e sur le port 3000 au sein de **`bin/www`**) :

```bash
npm start
```

Pour consommer l'op√©ration de lecture via un browser, nous pouvons lire toutes les ressources de type "pizzas" ici :
[http://localhost:3000/pizzas](http://localhost:3000/pizzas)

# <InternalPageTitle> Exercice 1.1 : lecture de toutes les ressources </InternalPageTitle>
Vous allez cr√©er la premi√®re version de la RESTful API de **myMovies**, un site qui permettra de pr√©senter des films. Vous devez, sous Express, mettre √† disposition cette op√©ration :

| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **`films`** | GET | READ ALL : Lire toutes les ressources de la collection |

<br/>

Une ressource de type **`films`** doit contenir les propri√©t√©s suivantes :
  - **`id`** : un entier 
  - **`title`** : titre du film (String)
  - **`duration`** : dur√©e du film en minutes ; elle doit √™tre un nombre positif (pas une string !).
  - **`budget`** : pour informer du co√ªt qu'a cout√© la production du film, en millions ; le budget doit √™tre un nombre positif (pas une string !).
  - **`link`** : pour donner une URL vers la description du film (lien vers imdb, rottentomatoes ou autre).

Veuillez donc "hardcoder" au moins trois ressources, parmi vos films pr√©f√©r√©s, dans un array au sein de votre RESTful API.

Le code de votre application doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/exercises/1.1`**.  
Veuillez faire un **`commit`** de votre code avec le message suivant : **`1.1 API : read`**.

# <InternalPageTitle> Exercice 1.2 : middleware s'ex√©cutant sur toutes les routes </InternalPageTitle>
## Application middleware de base
Veuillez cr√©er un middleware qui permet d'enregistrer et d'afficher dans la console des statistiques sur les requ√™tes faites √† votre API.

Vous devez enregistrer, depuis le d√©marrage du serveur, le nombre de requ√™tes **`GET`** faites √† votre API.

Voici un example de ce qui devrait √™tre affich√© dans la console √† chaque requ√™te vers votre API :
```bash
GET counter : 2
```

Le code de votre application doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/exercises/1.2`**.  
Veuillez faire un **`commit`** de votre code avec le message suivant : **`1.2 : app middleware`**.

#### ü§ù Tips
- Comment r√©cup√©rer la m√©thode HTTP ? **`req.method`** ...
- Comment appliquer un middleware √† toutes les routes ? revoir les **application-level middleware**...

## üç¨ Et si on allait un peu plus loin ?

Vous allez maintenant cat√©goriser le nombre d'appels par **`PATH`** et par **`m√©thode HTTP`**.

Voici un example de ce qui devrait √™tre affich√© dans la console √† chaque requ√™te vers votre API :
```bash
Request counter :
- GET / : 10
- GET /pizzas : 2
- POST /pizzas : 5
- DELETE /pizzas : 2
```

# <InternalPageTitle> Param√®tres de route </InternalPageTitle>

<div className="card card__simple-youtube-container">
    <YoutubeImage src="https://youtu.be/i-QAbJOppwM" />
</div>

Les **route parameters** sont des segments d'une URL qui sont utilis√©s pour capturer une valeur sp√©cifi√©e √† leur position dans l'URL. On r√©cup√®re ces param√®tres via l'objet **`req.params`**.

Pour notre pizzeria, nous souhaitons pouvoir lire une pizza identifi√©e par son **id**.

Nous allons donc ajouter le param√®tre de route **id**.  
En respect des conventions REST, un client devra faire ce genre de requ√™te pour appeler cette op√©ration : **`GET /pizzas/2`**.

Pour continuer le tutoriel que nous avons initi√© dans le r√©pertoire **`/tutorials/pizzeria/api/basic`**,  voici la nouvelle route √† ajouter dans le router **`/routes/pizza.js`** :
```js
// Read the pizza identified by an id in the menu
router.get('/:id', (req, res) => {
  console.log(`GET /pizzas/${req.params.id}`);

  const indexOfPizzaFound = MENU.findIndex((pizza) => pizza.id == req.params.id);

  if (indexOfPizzaFound < 0) return res.sendStatus(404);

  res.json(MENU[indexOfPizzaFound]);
});
```

Veuillez red√©marrer l'API (**`CTRL c`** puis **`npm start`**).

Pour consommer cette nouvelle op√©ration via un browser, nous pouvons lire la ressource de type "pizzas" identifi√©e par **2** dans le menu ainsi :
[http://localhost:3000/pizzas/2](http://localhost:3000/pizzas/2)

Le browser fait bien une requ√™te du genre : **`GET /pizzas/2`**.  
Le param√®tre de la route "2" est r√©cup√©r√© dans l'URL de la route par Express et est offert via **`req.params.id`**. 

N'h√©sitez pas √† faire une requ√™te pour un identifiant n'existant pas de le menu pour voir ce qui se passe : [http://localhost:3000/pizzas/666](http://localhost:3000/pizzas/666).

# <InternalPageTitle> Param√®tres de requ√™te </InternalPageTitle>

Les **query parameters** sont des param√®tres qui peuvent √™tre ajout√©s √† une URL.  
On r√©cup√®re ces param√®tres via l'objet **`req.query`**.

Pour notre pizzeria, nous souhaitons pouvoir lire toutes les ressources de type "pizzas" tri√©es par ordre ascendant ou descendant du titre.

En respect des conventions REST, un client devra faire ce genre de requ√™tes : 
- pour le tri ascendant : **`GET /pizzas?order=title`** ;
- pour le tri descendant : **`GET /pizzas?order=-title`**.

Il n'y a donc pas de nouvelle route √† ajouter ici. En effet, √ßa reste une requ√™te de type GET sur la route **`/pizzas`**. 

Veuillez donc mettre √† jour **`/routes/pizza.js`** pour la lecture de toutes les pizzas :
```js
/* Read all the pizzas from the menu
   GET /pizzas?order=title¬†:¬†ascending order¬†by¬†title
¬†  GET /pizzas?order=-title¬†:¬†descending order¬†by¬†title
*/
router.get('/', (req, res, next) => {
  const orderByTitle =
    req?.query?.order?.includes('title')
      ? req.query.order
      : undefined;
  let orderedMenu;
  console.log(`order by ${orderByTitle ?? 'not requested'}`);
  if (orderByTitle)
    orderedMenu = [...MENU].sort((a, b) => a.title.localeCompare(b.title));
  if (orderByTitle === '-title') orderedMenu = orderedMenu.reverse();

  console.log('GET /pizzas');
  res.json(orderedMenu ?? MENU);
});
```

Veuillez red√©marrer l'API (**`CTRL c`** puis **`npm start`**).

Pour consommer cette nouvelle op√©ration via un browser, nous pouvons lire toutes les ressources de type "pizzas" tri√©es par leur titre de mani√®re descendante :
[http://localhost:3000/pizzas?order=-title](http://localhost:3000/pizzas?order=-title).

N'h√©sitez pas √† tester d'autres tris.

# <InternalPageTitle> Op√©ration de cr√©ation & parsing du body </InternalPageTitle>

<div className="card card__simple-youtube-container">
    <YoutubeImage src="https://youtu.be/TwnPu-T7Wm0" />
</div>

Nous souhaitons d√©velopper une op√©ration permettant de cr√©er une ressource de type "pizzas".  
Selon les conventions REST, il faut faire une requ√™te de type **`POST /pizzas`** qui offre une repr√©sentation de la ressource √† cr√©er. La repr√©sentation utilis√©e est le JSON que nous verrons plus en d√©tails plus tard.  
Lors de l'ajout d'un film, si nous souhaitons cr√©er une ressource dont le titre est "Magic Green" et le contenu est "Epinards, Brocolis, Olives vertes, Basilic", la repr√©sentation de la ressource √† cr√©er sera la suivante :
```json
{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Selon les conventions REST, une requ√™te de cr√©ation est de type **POST** et contient ses **param√®tres 
au sein du body** de la requ√™te.

**`/routes/pizzas.js`** doit offrir une nouvelle route permettant d'ajouter une nouvelle pizza au menu, qui est un array d'objets. Une nouvelle pizza doit donc √™tre ajout√©e √† une variable, un array, qui est contenu dans la m√©moire vive de notre machine.  
Lorsque l'ajout d'une pizza au menu a r√©ussi, nous souhaitons renvoyer la repr√©sentation de la nouvelle ressource au client. Ainsi, le client aura notamment acc√®s √† l'**id** de la pizza cr√©√©e par l'API.

Voici le code du router **`/routes/pizzas.js`** pour la nouvelle op√©ration. Rajoutons-le dans notre application :
```js
// Create a pizza to be added to the menu.
router.post('/', (req, res) => {
  const title = req?.body?.title?.length !== 0 ? req.body.title : undefined;
  const content = req?.body?.content?.length !== 0 ? req.body.content : undefined;

  console.log('POST /pizzas');

  if (!title || !content) return res.sendStatus(400); // error code '400 Bad request'

  const lastItemIndex = MENU?.length !== 0 ? MENU.length - 1 : undefined;
  const lastId = lastItemIndex !== undefined ? MENU[lastItemIndex]?.id : 0;
  const nextId = lastId + 1;

  const newPizza = {
    id: nextId,
    title: title,
    content: content,
  };

  MENU.push(newPizza);

  res.json(newPizza);
});
```

La repr√©sentation de la ressource √† cr√©er est pars√©e dans l'objet **`req.body`** gr√¢ce √† la fonction middleware **`express.json()`** appel√©e dans **`/app.js`** :
```js
app.use(express.json());
```

Il est donc important de ne pas retirer cette ligne lorsque l'on cr√©e une RESTful API.

OK, c'est bien, mais comment tester ce nouveau code ?

Le browser permet de facilement cr√©er des requ√™tes de type **GET**, mais pas des requ√™tes de type **POST**...   
Nous avons donc besoin d'un client l√©ger permettant de faire des requ√™tes HTTP.

# <InternalPageTitle> Client REST </InternalPageTitle>

## Introduction
Dans le cadre de ce cours, tout comme g√©n√©ralement dans un environnement professionnel, nous souhaitons pouvoir d√©velopper une API ind√©pendamment du d√©veloppement d'une IHM (Interface Homme Machine, ce sont les √©crans permettant d'interagir avec l'application web).

En effet, cela prendrait trop de temps de devoir d√©velopper un frontend (HTML / JavaScript / CSS) pour tester nos API.

Nous allons donc utiliser un client l√©ger permettant de faire des requ√™tes √† nos API.  
Il en existe de nombreux, comme [REST Client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client) [[R.55]](/references/#r55) ou [Postman](https://www.postman.com/) [[R.56]](/references/#r56).

## REST Client
Dans le cadre de ce cours, nous utilisons [REST Client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client) [[R.55]](/references/#r55) de Visual Studio Code pour tester nos API.

Pour installer REST Client au sein de VS Code, veuillez cliquer sur l'onglet **Extensions**. 

Recherchez l'extension **REST Client** et cliquez sur **Install**.

Quelques notions pour utiliser REST Client :
- Il faut cr√©er un fichier **`.http`** (ou **`.rest`**) contenant les requ√™tes vers vos RESTful APIs.  
NB : Il est appropri√© de cr√©er un fichier par type de ressources.
- Chaque requ√™te est introduite par **`###`** (3 "**`#`**"" ou plus) ; voici la requ√™te permettant de lire toutes les pizzas :
```http
### Read all pizzas
GET http://localhost:3000/pizzas
```
- Pour ex√©cuter une requ√™te, il suffit de cliquer sur **`Send Request`**.
- Lorsqu'on envoie des donn√©es au format JSON, il est important d'avoir un espace avant les accolades (avant le "**`{`**" ).
- On peut d√©finir des **File variables** via ce genre de syntaxe : **`@baseUrl = http://localhost:3000`**.
- Pour utiliser la variable **`baseUrl`**, il suffit de la mettre entre double accolades. Par exemple, voici la requ√™te permettant de lire toutes les pizzas :  
```http
### Read all pizzas with File variable
@baseUrl = http://localhost:3000
GET {{baseUrl}}/pizzas
```

Nous allons maintenant tester l'API de la pizzeria que nous avons cr√©√©e pour toutes ses op√©rations.

Au sein de VS Code, dans votre projet **`/tutorials/pizzeria/api/basic`**, veuillez cr√©er un r√©pertoire nomm√© **`REST Client`**. Dans ce r√©pertoire, veuillez cr√©er un fichier nomm√© **`pizzas.http`**.

Dans **`pizzas.http`**, veuillez ajouter cette requ√™te pour la lecture de toutes les pizzas et ex√©cutez la : 
```http
### Read all pizzas with File variable
@baseUrl = http://localhost:3000
GET {{baseUrl}}/pizzas
```

Est-ce que cela fonctionne bien ?  Avez vous bien d√©marr√© votre API ?  
Vous devriez obtenir le m√™me r√©sultat que si vous acc√©diez √† votre API √† l'aide du browser.

Au sein de **`pizzas.http`**, veuillez ajouter ces deux requ√™tes pour la lecture de toutes les pizzas en les triant selon leur titre :
```http
### Read all pizzas sorted by title (ascending)
GET {{baseUrl}}/pizzas/?order=+title

### Read all pizzas sorted by title (descending)
GET {{baseUrl}}/pizzas/?order=-title
```

Veuillez ex√©cuter ces deux requ√™tes.

Nous sommes pr√™ts pour ajouter une requ√™te appelant l'op√©ration de cr√©ation d'une pizza.

Au sein de **`pizzas.http`**, veuillez ajouter cette requ√™te pour la cr√©ation d'une pizza :
```http
### Create a pizza
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

On remarque qu'il est important de mettre une ligne vide avant les accolades repr√©sentant le body de la requ√™te.

üí≠ Comment tester que le bon fonctionnement de l'op√©ration de cr√©ation ?

Et bien il suffit d'ex√©cuter l'op√©ration de lecture de toutes les pizzas üòé !
Lors de l'ajout d'un film, si la nouvelle ressource appara√Æt, c'est qu'elle a bien √©t√© cr√©√©e !
Faites le test !

# <InternalPageTitle> Exercice 1.3 : lectures sp√©cifiques, cr√©ation & REST Client </InternalPageTitle>

Veuillez continuer le d√©veloppement de la RESTful API de **myMovies**, sous Express, afin de mettre √† disposition de nouvelles op√©rations sur des films et utiliser **REST Client**.

Veuillez repartir du code de la solution de votre [Exercice 1.1](#exercice_1_1_lecture_de_toutes_les_ressources) ou de votre [Exercice 1.2](#exercice_1_2_middleware_sexecutant_sur_toutes_les_routes) si celui-ci contient l'op√©ration de lecture de tous les films.

Veuillez rajouter ces op√©rations √† votre API :

| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **`films?minimum-duration=value`** | GET | READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donn√© |
| **`films/{id}`** | GET | READ ONE : Lire la ressource identifi√©e |
| **`films`** | POST | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |

<br/>

Pour rappel, une ressource de type **`films`** doit contenir les propri√©t√©s suivantes :
  - **`id`** : un entier 
  - **`title`** : titre du film (String)
  - **`duration`** : dur√©e du film en minutes ; elle doit √™tre un nombre positif (pas une string !).
  - **`budget`** : pour informer du co√ªt qu'a cout√© la production du film, en millions ; le budget doit √™tre un nombre positif (pas une string !).
  - **`link`** : pour donner une URL vers la description du film (lien vers imdb, rottentomatoes ou autre).

Les ressources ne doivent toujours pas persister : d√®s lors, ajoutez les donn√©es associ√©es aux films dans un array.

Veuillez bien valider les param√®tres re√ßu par les op√©rations de vos API ; v√©rifiez par exemple que **`budget`** et **`duration`** sont des **nombres positifs**. 

Veuillez **tester toutes les fonctions de la RESTful API** pour la collection de films √† l'aide du **REST Client** dans VS Code. Veuillez ajouter vos requ√™tes au sein du fichier **`films.http`** dans le r√©pertoire **REST Client** du dossier associ√© √† cet exercice.

Le code de votre application doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/exercises/1.3`**.  
Veuillez faire un **`commit`** de votre code avec le message suivant : **`1.3 : API : create & REST client`**.

#### ü§ù Tips
- D√©veloppez les op√©rations de votre API de mani√®re incr√©mentale : testez une op√©ration via REST Client avant de passer √† une nouvelle op√©ration.
- Pour le filtre sur les films, vous allez r√©cup√©rer un param√®tre de requ√™te.  
‚ö° Attention, le signe **`-`** est un op√©rateur en JS, vous ne pouvez pas r√©cup√©rer le param√®tre de requ√™te via **`req.query.minimum-duration`**...  
üí≠ Mais alors comment faire ?  
On acc√®de aussi au propri√©t√© d'un objet √† l'aide d'un array, ici √ßa serait via **`req.query['minimum-duration']`**.
- N'h√©sitez pas √† vous inspirer du code du tutoriel [api-basic](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/basic).
- Pour v√©rifier le type d'une variable, n'h√©sitez pas √† utiliser l'op√©rateur **`typeof`**.


# <InternalPageTitle> üç¨ Exercice 1.4 : Gestion de la pagination, du tri et du filtrage </InternalPageTitle>

N'h√©sitez pas, c'est optionnel, de g√©rer de nouvelles op√©rations au sein de votre RESTful API de **myMovies** :
-	Filtrez tous les films qui commencent par une certaines cha√Ænes de caract√®res.
-	Permettez de trier les films.

Le code de votre application est √† ajouter dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/exercises/1.4`**.  
Veuillez faire un **`commit`** de votre code avec le message suivant : **`1.4 : API : ordering & filtering client`**.

üç¨ Et si vraiment vous avez encore du temps et souhaitez d√©j√† approfondir les RESTful APIs, n'h√©sitez pas aussi √† impl√©menter la gestion de la pagination. Pour cette partie, veuillez faire un **`commit`** de votre code avec le message suivant : **`1.4 : API : pagination`**.

#### ü§ù Tips
Besoin d'inspiration pour l'aspect filtrage et la gestion du tri des ressources ? [REST API Guide](https://dev.to/drminnaar/rest-api-guide-14n2) [[R.58]](/references/#r58).


# <InternalPageTitle> Codes de statut HTTP associ√©s aux r√©ponses </InternalPageTitle>

<div className="card card__simple-youtube-container">
    <YoutubeImage src="https://youtu.be/OHd092ILf7g" />
</div>

On ne peut pas toujours renvoyer du JSON suite √† une requ√™te client ainsi qu'un code HTTP correspondant au fait que tout est OK (**`200 OK`**).

Quand vous ex√©cutez cette requ√™te :
```http
### Read all pizzas with File variable
GET {{baseUrl}}/pizzas
```

Vous faites appel √† l'op√©ration de lecture de toutes les pizzas. La derni√®re ligne de cette op√©ration est la suivante :
```js
res.json(orderedMenu ?? MENU);
```

La fonction **`json`** renvoie une r√©ponse au format JSON, mais de plus, elle renvoie un **status code** **`200`** indiquant au client que tout s'est bien pass√©.

Au sein de **`pizzas.http`**, veuillez ajouter cette requ√™te pour tenter de cr√©er une pizza en oubliant un param√®tre :
```http
### Create a pizza which lacks a property
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Veuillez ex√©cuter cette requ√™te. Que se passe-t-il ?  
On r√©cup√®re un code d'erreur **`400 Bad Request`**.

En effet, lorsqu'on omet un param√®tre dans la repr√©sentation de la ressource √† cr√©er, voici les lignes de code amenant au renvoi du code d'erreur **`400`** au sein de **`pizzas.js`** :
```js numbered highlighting="3,4,8"
// Create a pizza to be added to the menu.
router.post('/', (req, res) => {
  const title = req?.body?.title?.length !== 0 ? req.body.title : undefined;
  const content = req?.body?.content?.length !== 0 ? req.body.content : undefined;

  console.log('POST /pizzas');

  if (!title || !content) return res.sendStatus(400); // error code '400 Bad request'

  const lastItemIndex = MENU?.length !== 0 ? MENU.length - 1 : undefined;
  const lastId = lastItemIndex !== undefined ? MENU[lastItemIndex]?.id : 0;
  const nextId = lastId + 1;

  const newPizza = {
    id: nextId,
    title: title,
    content: content,
  };

  MENU.push(newPizza);

  res.json(newPizza);
});
```

Le client est donc bien inform√© qu'il y a eu un probl√®me lors de l'ex√©cution de l'op√©ration.   
Il pourrait par exemple utiliser cette information pour pr√©senter un message d'erreur au niveau d'une IHM.

Voici les grandes cat√©gories de "status codes" :
- R√©ponses informatives : **`100-199`**
- R√©ponses en cas de succ√®s : **`200-299`**
- Redirections : **`300-399`**
- Erreurs du client : **`400-499`**
- Erreurs du serveur : **`500-599`**

Voici les "status codes" que nous allons g√©n√©ralement utiliser :
- **`200 OK`** : tout s'est bien pass√©, Express ajoute ce code automatiquement pour nous quand nous utilisons une m√©thode comme **`res.json()`**.
- **`400 Bad Request`** : pour indiquer au client que la requ√™te contient des param√®tres non valides ou n'est pas compl√®te.
- **`401 Unauthorized`** : pour indiquer au client qu'il doit s'authentifier pour acc√©der √† cette op√©ration. On renvoie aussi ce code d'erreur quand un client fournit un mauvais username ou password.
- **`403 Forbidden`** : le client est connu du serveur, mais il n'a pas les privil√®ges pour acc√©der √† cette op√©ration (par exemple, le client n'est pas admin et tente d'acc√©der √† une op√©ration seulement accessible √† un admin).
- **`404 Not Found`** : la ressource demand√©e n'existe pas, bien que l'URL semble valide.
- **`409 Conflict`** : l'√©tat du serveur entre en conflit avec la requ√™te. Par exemple, la requ√™te demande de cr√©er un utilisateur qui existe d√©j√†.
- **`500 Internal Server Error`** : le serveur a rencontr√© une erreur qu'il ne peut pas r√©gler. Par exemple, le serveur de base de donn√©es ne r√©pond pas et ne permet donc pas d'acc√©der aux ressources.

# <InternalPageTitle> Exercice 1.5 : codes de statut HTTP </InternalPageTitle>

Veuillez continuer le d√©veloppement de la RESTful API de **myMovies**, sous Express, afin de mieux g√©rer la la lecture et la cr√©ation de films et le r√©ponses √† donner aux clients.

Veuillez repartir du code de la solution de votre [Exercice 1.3](#exercice_1_3_lectures_specifiques_creation_rest_client) ou de votre [Exercice 1.4 optionnel](#üç¨_exercice_1_4_gestion_de_la_pagination_du_tri_et_du_filtrage).

Veuillez am√©liorer les deux op√©rations de lecture (**`GET /films`** & **`GET /films/:id`**) et l'op√©ration de cr√©ation de films (**`POST /films`**):
- En cas d'√©chec de la validation des param√®tres re√ßus par une op√©ration (non respect du contrat de l'API), veuillez renvoyer le status code appropri√©.
- Lors de l'√©chec de la lecture d'un film en particulier, veuillez renvoyer le status code appropri√©.
- Lors de l'ajout d'un film, si la ressource existe d√©j√†, c'est-√†-dire s'il y a d√©j√† un film pr√©sent avec le **`title`** donn√©, veuillez renvoyer le status code appropri√©.

Le code de votre application doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/exercises/1.5`**.  
Veuillez faire un **`commit`** de votre code avec le message suivant : **`1.5 : API : status code`**.

# <InternalPageTitle> Op√©rations de suppression & de modification </InternalPageTitle>

<div className="card card__simple-youtube-container">
    <YoutubeImage src="https://youtu.be/1AQ9BknswUI" />
</div>

## Op√©ration de suppression
Nous souhaitons d√©velopper une op√©ration permettant de supprimer une ressource de type "pizzas" √† l'aide de son identifiant.  

Selon les conventions REST, une **op√©ration de suppression**:
- est associ√©e √† une requ√™te de type **`DELETE /pizzas/{id}`** contenant l'**identifiant** de la ressource √† supprimer au sein de l'URI comme **param√®tre de route**.
- **ne contient pas de donn√©es dans le body** et est de **type DELETE**.

Voici le code du router **`/routes/pizzas.js`** pour la nouvelle op√©ration, veuillez la rajouter dans le r√©pertoire de votre tutoriel en cours :
```js
// Delete a pizza from the menu based on its id
router.delete('/:id', (req, res) => {
  console.log(`DELETE /pizzas/${req.params.id}`);

  const foundIndex = MENU.findIndex(pizza => pizza.id == req.params.id);

  if (foundIndex < 0) return res.sendStatus(404);

  const itemsRemovedFromMenu = MENU.splice(foundIndex, 1);
  const itemRemoved = itemsRemovedFromMenu[0];

  res.json(itemRemoved);
});
```

Au sein de **`pizzas.http`**, veuillez ajouter cette requ√™te pour supprimer la pizza poss√©dant l'identifiant "2" :
```http
### Delete pizza identified by 2
DELETE {{baseUrl}}/pizzas/2
```

Veuillez ex√©cuter cette requ√™te et v√©rifier que la pizza a bien √©t√© supprim√©e.

## Op√©ration de modification
Nous souhaitons d√©velopper une op√©ration permettant de modifier une ressource de type "pizzas" √† l'aide de son identifiant et de nouvelles valeurs pour ses propri√©t√©s. 

Selon les conventions REST, une **op√©ration de modification** :
- si l'on accepte de modifier que certaines des propri√©t√©s d'une pizza (qu'il ne faut donc pas fournir toutes les propri√©t√©s d'une pizza), est associ√©e √† une requ√™te de type **`PATCH /pizzas/{id}`** contenant l'**identifiant** de la ressource √† supprimer au sein de l'URL comme **param√®tre de route**.
- **contient les nouvelles donn√©es au sein du body** et est de **type PATCH ou PUT**.

Lors de l'ajout d'un film, si nous souhaitons modifier une ressource identifi√©e par **`6`** en fournissant un nouveau titre "Magic Green 2", la repr√©sentation des donn√©es de la ressource √† modifier sera la suivante :
```json
{
    "title":"Magic Green 2"
}
```

Selon les conventions REST, la requ√™te de modification est de type PATCH et contient ses param√®tres au sein du body de la requ√™te.

Voici le code du router **`/routes/pizzas.js`** pour la nouvelle op√©ration √† rajouter dans votre tutoriel en cours :
```js
// Update a pizza based on its id and new values for its parameters
router.patch('/:id', (req, res) => {
  console.log(`PATCH /pizzas/${req.params.id}`);

  const title = req?.body?.title;
  const content = req?.body?.content;

  console.log('POST /pizzas');

  if ((!title && !content) || title?.length === 0 || content?.length === 0) return res.sendStatus(400);

  const foundIndex = MENU.findIndex(pizza => pizza.id == req.params.id);

  if (foundIndex < 0) return res.sendStatus(404);

  const updatedPizza = {...MENU[foundIndex], ...req.body};

  MENU[foundIndex] = updatedPizza;

  res.json(updatedPizza);
});
```

Au sein de **`pizzas.http`**, veuillez ajouter cette requ√™te pour modifier la pizza poss√©dant l'identifiant "6" :
```http
### Update the pizza identified by 6
PATCH {{baseUrl}}/pizzas/6
Content-Type: application/json

{
    "title":"Magic Green 2"
}
```

Veuillez ex√©cuter cette requ√™te et v√©rifier que la pizza a bien √©t√© modifi√©e.

üí≠ Cela ne fonctionne pas ?  
Avez vous pr√©c√©demment ex√©cut√© la requ√™te permettant de cr√©er une sixi√®me pizza.

Lors de l'ajout d'un film, si votre tutoriel fonctionne bien, faites un **commit** de votre repo (**web2**) avec comme message : **`api-basic tutorial`**.

En cas de souci, vous pouvez acc√©der au code du tutoriel ici : [api-basic](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/basic).

# <InternalPageTitle> Exercice 1.6 : suppression & modification de ressources </InternalPageTitle>

Veuillez continuer le d√©veloppement de la RESTful API de **myMovies**, sous Express, afin d'ajouter les op√©rations de suppression et de modification de ressources.

Veuillez repartir du code de la solution de votre [Exercice 1.5](#exercice_1_5_codes_de_statut_http).

Veuillez ajouter ces trois nouvelles op√©rations :

| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **`films/{id}`** | DELETE | DELETE ONE : Effacer la ressource identifi√©e |
| **`films/{id}`** | PATCH | UPDATE ONE : Mettre √† jour les propri√©t√©s de la ressource par les valeurs donn√©es dans la requ√™te, pour une ou plusieurs propri√©t√©s |
| **`films/{id}`** | PUT | UPDATE ONE or CREATE ONE : Remplacer la ressource par une ressource reprenant les valeurs donn√©es dans la requ√™te, seulement si toutes les propri√©t√©s de la ressource sont donn√©es ! Si la ressource n'existe pas, cr√©er cette ressource seulement si l'**id** donn√© n'est pas d√©j√† existant. |

Veuillez bien valider les param√®tres re√ßus par les op√©rations de vos API ; v√©rifiez par exemple que **`budget`** et **`duration`** sont des **nombres positifs**. 

Veuillez **tester toutes les fonctions de la RESTful API** pour la collection de films √† l'aide du **REST Client** dans VS Code. Veuillez ajouter vos requ√™tes au sein du fichier **`films.http`** dans le r√©pertoire **REST Client** du dossier associ√© √† cet exercice.

Le code de votre application doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/exercises/1.6`**.  
Veuillez faire un **`commit`** de votre code avec le message suivant : **`1.6 : API : delete & modify`**.


