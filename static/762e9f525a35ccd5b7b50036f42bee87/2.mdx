---
title: "Module 2 : JAX-RS & auths"
description: "Authentification & autorisation au sein de JAX-RS"
---

# Module 2 : JAX-RS & auths
Ce module vous offre le refactor d'une application JAX-RS tout en mettant en oeuvre le mécanisme 
d'authentification et d'autorisation d'accès aux opérations. 

Voici les sujets traités :
- a) [Refactor d'une application JAX-RS](/modules/2#sectionA)
- b) [Configuration de l'application via un fichier .properties](/modules/2#sectionB)
- c) [Rappel de conventions sur les RESTful APIs, authentification & autorisation](/modules/2#sectionC)
- d) [Authentification & création de token JWT](/modules/2#sectionD)
- e) [Utilisation de jbcrypt pour gérer les passwords](/modules/2#sectionE)
- f) [Autorisation JWT, filtres, providers & "Name binding"](/modules/2#sectionF)
- g) [Envoi de requêtes à ses APIs](/modules/2#sectionG)
- h) [Gestion des requêtes contenant des objets JSON quelconques](/modules/2#sectionH)
- i) [Gestion des réponses et sérialisation d’objets JSON quelconques](/modules/2#sectionI)
- j) [Exercice 2.1](/modules/2#sectionJ)

<br/>

# <a id="sectionA"></a>a) Refactor d'une application JAX-RS
## a.1) Refactor général
Dans le Module 1, nous avons développé ensemble une RESTful API permettant de gérer des films.

Nous allons maintenant faire un refactor de cette application afin de mieux architecturer le code.
Voici les motivations pour réarchitecturer l'API :
1. Souhait de ne pas mixer le code associé à la présentation des ressources, c'est-à-dire le code 
s'occupant des réponses aux requêtes clients, au code associé à la gestion des données ;
on veut pouvoir mettre à jour la couche d'accès aux données sans devoir mettre à jour les Root Ressources.
2. La partie business de l'application, en d'autres mots la logique d'accès aux opérations sur les 
données, ne doit pas être séparée de la gestion des données.
3. On veut pouvoir rapidement distinguer certaines parties de code : les objets du domaine, le main,  
les opérations offertes sur les ressources, les utilitaires, la logique d'accès 
aux opérations sur les données et la gestion des données.

<br/>

Pour ce faire, nous veuillez créer ces packages au sein de votre API gérant les films :
- **api** : s'occupera des Root Resources et donc de la présentation des ressources aux clients.
- **domain** : inclura tous les objets du domaines, les sacs de données.
- **main** : gère le démarrage de l'application JAX-RS.
- **services** : permet de traiter de la logique d'accès aux opérations sur les données et la gestion de 
ces données.
- **utils** : traite des morceaux de code réutilisables sur potentiellement toutes les applications 
JAX-RS (gestion de la config par exemple).

<br/>

Veuillez déplacer vos classes dans les bons packages. 
La classe **Json** est à reprendre actuellement au sein du package **services**.
<br/>

Au sein du package **services**, veuillez créer une nouvelle classe **FilmDataService** qui 
s'occupera de la logique et de l'accès aux données en faisant appel aux méthodes de la classe **Json**.
Voici le code de **FilmDataService** :
```java
package be.vinci.services;

import be.vinci.domain.Film;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import org.apache.commons.text.StringEscapeUtils;

import java.util.List;

public class FilmDataService {
    public List<Film> getAll(int minimumDuration) {
        var films = Json.parse();
        if (minimumDuration != -1) {
            List<Film> filmsFiltered = films.stream().filter(film -> film.getDuration() >= minimumDuration)
                    .toList();
            return filmsFiltered;
        }
        return films;
    }


    public Film getOne(int id) {
        var films = Json.parse();
        Film filmFound = films.stream().filter(film -> film.getId() == id).findAny().orElse(null);
        return filmFound;
    }

    public Film createOne(Film film) {
        var films = Json.parse();
        film.setId(nextFilmId());
        film.setTitle(StringEscapeUtils.escapeHtml4(film.getTitle()));
        film.setLink(StringEscapeUtils.escapeHtml4(film.getLink()));
        films.add(film);
        Json.serialize(films);
        return film;
    }


    public Film deleteOne(int id) {
        var films = Json.parse();
        Film filmToDelete = films.stream().filter(film -> film.getId() == id).findAny().orElse(null);
        films.remove(filmToDelete);
        Json.serialize(films);
        return filmToDelete;
    }

    public Film updateOne(Film film, int id) {
        var films = Json.parse();
        Film filmToUpdate = films.stream().filter(f -> f.getId() == id).findAny().orElse(null);
        film.setId(id);
        film.setTitle(StringEscapeUtils.escapeHtml4(film.getTitle()));
        film.setLink(StringEscapeUtils.escapeHtml4(film.getLink()));
        films.remove(film); // thanks to equals(), films is found via its id
        films.add(film);
        Json.serialize(films);
        return film;
    }

    public int nextFilmId() {
        var films = Json.parse();
        if (films.size() == 0)
            return 1;
        return films.get(films.size() - 1).getId() + 1;
    }
}

```
<br/>

Dans le **Main**, faites en sorte de découvrir les ressources que dans le package **api** :
```java {1}
final ResourceConfig rc = new ResourceConfig().packages("be.vinci.api")
                .register(JacksonFeature.class);
```
<br/>

Dans **FilmResource**, créez une instance de **FilmDataService** et faites appel aux méthodes offertes par vos services :
```java numbered {5,10,18,32,42,57}
@Singleton
@Path("films")
public class FilmResource {

    private FilmDataService myFilmDataService = new FilmDataService();

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public List<Film> getAll(@DefaultValue("-1") @QueryParam("minimum-duration") int minimumDuration) {
        return myFilmDataService.getAll(minimumDuration);
    }


    @GET
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Film getOne(@PathParam("id") int id) {
        Film filmFound = myFilmDataService.getOne(id);
        if (filmFound == null)
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity("Ressource not found").type("text/plain").build());
        return filmFound;
    }

    @POST
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    public Film createOne(Film film) {
        if (film == null || film.getTitle() == null || film.getTitle().isBlank())
            throw new WebApplicationException(
                    Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory info").type("text/plain").build());
        return myFilmDataService.createOne(film);
    }

    @DELETE
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Film deleteOne(@PathParam("id") int id) {
        if (id == 0) // default value of an integer => has not been initialized
            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory id info")
                    .type("text/plain").build());
        Film deletedFilm = myFilmDataService.deleteOne(id);
        if (deletedFilm == null)
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity("Ressource not found").type("text/plain").build());
        return deletedFilm;
    }

    @PUT
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    public Film updateOne(Film film, @PathParam("id") int id) {
        if (id == 0 || film == null || film.getTitle() == null || film.getTitle().isBlank())
            throw new WebApplicationException(
                    Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory info").type("text/plain").build());
        Film updatedFilm = myFilmDataService.updateOne(film, id);
        if (updatedFilm == null)
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity("Ressource not found").type("text/plain").build());
        return updatedFilm;
    }
}
```
<br/>

Veuillez exécuter et tester l'application pour vous assurer que celle-ci rende le même service
que précédemment.

<br/>

## a.2) Création d'un utilitaire utile pour tous les services de données
Nous allons maintenant généraliser la classe **Json** afin qu'elle puisse être utilisée avec 
n'importe quel service de données (pour n'importe quel type de ressources : 
des films, des textes...).
<br/>

Veuillez créer le package **utils** au sein du package **services**.
Nous allons maintenant rendre générique la classe **Json** afin de la paramétrer sur base du type 
associé aux ressources.
Voici le code mis à jour de la classe **Json** : 
```java
public class Json<T> {
    private static final String DB_FILE_PATH = "db.json";
    private static Path pathToDb = Paths.get(DB_FILE_PATH);
    private final static ObjectMapper jsonMapper = new ObjectMapper();
    private T type;

    public void serialize(List<T> items, String collectionName) {
        try {
            // if no DB file, write a new collection to a new db file
            if (!Files.exists(pathToDb)) {
                // Create an object and add a JSON array as POJO, e.g. { items:[...]}
                ObjectNode newCollection = jsonMapper.createObjectNode().putPOJO(collectionName, items);
                jsonMapper.writeValue(pathToDb.toFile(), newCollection); // write the JSON Object in the DB file
                return;
            }
            // get all collections : can be read as generic JsonNode, if it can be Object or Array;
            JsonNode allCollections = jsonMapper.readTree(pathToDb.toFile()); // e.g. { users:[...], items:[...]}
            // remove current collection, e.g. remove the array of items
            if (allCollections.has(collectionName)) {
                ((ObjectNode) allCollections).remove(collectionName); //e.g. it leaves { users:[...]}
            }
            // Prepare a JSON array from the list of POJOs for the collection to be updated, e.g. [{"film1",...}, ...]
            ArrayNode updatedCollection = jsonMapper.valueToTree(items);
            // Add the JSON array in allCollections, e.g. : { users:[...], items:[...]}
            ((ObjectNode) allCollections).putArray(collectionName).addAll(updatedCollection);
            // write to the db file allCollections
            jsonMapper.writeValue(pathToDb.toFile(), allCollections);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public List<T> parse(String collectionName) {
        try {
            // get allCollections
            JsonNode node = jsonMapper.readTree(pathToDb.toFile());
            // accessing value of the specified field of an object node,
            // e.g. the JSON array within "items" field of { users:[...], items:[...]}
            JsonNode collection = node.get(collectionName);
            if (collection == null) // Send an empty list if there is not the requested collection
                return (List<T>) new ArrayList<T>();
            // convert the JsonNode to a List of POJOs & return it
            return jsonMapper.readerForListOf(Film.class).readValue(collection);
        } catch (FileNotFoundException e) {
            return (List<T>) new ArrayList<T>(); // send an empty list if there is no db file
        } catch (IOException e) {
            e.printStackTrace();
            return (List<T>) new ArrayList<T>();
        }
    }

}
```
<br/>

Il faut aussi mettre à jour **FilmDataService** afin de paramétrer l'appel aux méthodes de la 
classe **Json** :
```java
public class FilmDataService {
    private static final String COLLECTION_NAME = "films";
    private static Json<Film> jsonDB = new Json<>();


    public List<Film> getAll(int minimumDuration) {
        var films = jsonDB.parse(COLLECTION_NAME);
        if (minimumDuration != -1) {
            List<Film> filmsFiltered = films.stream().filter(film -> film.getDuration() >= minimumDuration)
                    .toList();
            return filmsFiltered;
        }
        return films;
    }


    public Film getOne(int id) {
        var films = jsonDB.parse(COLLECTION_NAME);
        Film filmFound = films.stream().filter(film -> film.getId() == id).findAny().orElse(null);
        return filmFound;
    }

    public Film createOne(Film film) {
        var films = jsonDB.parse(COLLECTION_NAME);
        film.setId(nextFilmId());
        film.setTitle(StringEscapeUtils.escapeHtml4(film.getTitle()));
        film.setLink(StringEscapeUtils.escapeHtml4(film.getLink()));
        films.add(film);
        jsonDB.serialize(films, COLLECTION_NAME);
        return film;
    }


    public Film deleteOne(int id) {
        var films = jsonDB.parse(COLLECTION_NAME);
        Film filmToDelete = films.stream().filter(film -> film.getId() == id).findAny().orElse(null);
        films.remove(filmToDelete);
        jsonDB.serialize(films, COLLECTION_NAME);
        return filmToDelete;
    }

    public Film updateOne(Film film, int id) {
        var films = jsonDB.parse(COLLECTION_NAME);
        Film filmToUpdate = films.stream().filter(f -> f.getId() == id).findAny().orElse(null);
        film.setId(id);
        film.setTitle(StringEscapeUtils.escapeHtml4(film.getTitle()));
        film.setLink(StringEscapeUtils.escapeHtml4(film.getLink()));
        films.remove(film); // thanks to equals(), films is found via its id
        films.add(film);
        jsonDB.serialize(films, COLLECTION_NAME);
        return film;
    }

    public int nextFilmId() {
        var films = jsonDB.parse(COLLECTION_NAME);
        if (films.size() == 0)
            return 1;
        return films.get(films.size() - 1).getId() + 1;
    }
}
```
<br/>


Veuillez exécuter et tester votre application JAX-RS pour vous assurer que celle-ci est bien 
fonctionnelle.

<br/>

# <a id="sectionB"></a>b) Configuration de l'application via un fichier .properties
Une bonne pratique est de rendre configurable son application Java via un fichier **.properties**.

Nous allons rendre cela possible en modifiant notre API de gestion de films.
Veuillez créer la classe **Config** dans le package **utils** : 
```java
package be.vinci.utils;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

import jakarta.ws.rs.WebApplicationException;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.Status;

public class Config {

    private static Properties props;

    public static void load(String file) {
        props = new Properties();
        try (InputStream input = new FileInputStream(file)) {
            props.load(input);
        } catch (IOException e) {
            throw new WebApplicationException(
                    Response.status(Status.INTERNAL_SERVER_ERROR).entity(e.getMessage()).type("text/plain").build());
        }
    }

    public static String getProperty(String key) {
        return props.getProperty(key);
    }

    public static Integer getIntProperty(String key) {
        return Integer.parseInt(props.getProperty(key));
    }

    public static boolean getBoolProperty(String key) {
        return Boolean.parseBoolean(props.getProperty(key));
    }

}
```
<br/>

Cette classe **Config** permet de charger toutes les paramètres de configuration de l’application.
<br/>

Les paramètres de configuration de l'application, ou propriétés, sont à ajouter manuellement 
dans un fichier **.properties**. Ce fichier contient des propriétés sous forme de **key=value**, 
comme par exemple l’URL du serveur intégré à l’application JAX-RS.

Veuillez ajouter le fichier **dev.properties** à la racine de votre projet :
```
BaseUri=http://localhost:8080/
DatabaseFilePath=db.json
```
<br/>

Pour que les propriétés soient disponibles dans tout le programme, le chargement des propriétés 
se trouvant dans le fichier **/dev.properties** se fait dans le **Main**, au début de l'exécution 
de la méthode **main**, ou même avant l'exécution de cette méthode.
Vous pourriez ajouter cette ligne dans la fonction **main**, avant de créer le serveur Http :
```java
Config.load("dev.properties");
```
<br/>

Mais nous vous proposons d'utiliser un initialiseur "static" qui sera appelé avant la méthode 
**main**. Veuillez mettre à jour votre classe **Main** en ajoutant :
```java {2-4}
public class Main {
    static{
        Config.load("dev.properties");
    }
```
<br/>

L’utilisation d’une propriété, comme par exemple l’URL du serveur intégré à l’application JAX-RS,
se fait via l'appel de **getProperty** de **Config** (ou **getIntProperty** ou **getBoolProperty**). 

Veuillez mettre à jour la classe **Main** :
```java {6}
public class Main {
    static{
        Config.load("dev.properties");
    }
    // Base URI the Grizzly HTTP server will listen on
    public static final String BASE_URI = Config.getProperty("BaseUri");
```
<br/>

Veuillez aussi mettre à jour la classe **Json** pour utiliser la propriété associée au chemin
vers le fichier **db.json** :
```java {2}
public class Json<T> {
    private static final String DB_FILE_PATH = Config.getProperty("DatabaseFilePath");
```
<br/>

# <a id="sectionC"></a>c) Rappel de conventions sur les RESTful APIs, authentification & autorisation
## c.1) Conventions sur les RESTful APIs
Pour rappel, un RESTful web service, ou RESTful API, met à disposition des opérations 
sur des ressources. Ces opérations seront disponibles via des requêtes http associées à des 
URLs construites selon les conventions RESTful.
<br/>

Certaines opérations sont protégées par des tokens JWT. 
Ainsi, tout client souhaitant accéder à ces opérations devra fournir un token dans le header 
de la requête.
Le client devra donc mémoriser le token reçu lors de son enregistrement (**auths/register**) ou 
lors de son login (**auths/login**) afin de le fournir à chaque requête vers une opération 
protégée.

Voici les tableaux formalisant toutes les opérations associées à la RESTful API permettant de gérer 
des films :

<br/>

##### Tableau 1 : opérations sur les ressources de type "Authentification"
| URI | Méthode HTTP | Auths? | Opération |
|---|---|---|---|
| **auths/login** | POST | Non | Vérifier les « credentials » d’un User et renvoyer le User et un token JWT s’ils sont OK |
| **auths/register** | POST | Non | Créer une ressource User et un token JWT et les renvoyer |

<br/>

##### Tableau 2 : opérations sur les ressources de type "Film"
| URI | Méthode HTTP | Auths? | Opération |
|---|---|---|---|
| **films** | GET | Non | READ ALL : Lire toutes les ressources de la collection |
| **films?minimumduration=value** | GET | Non | READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donné |
| **films/{id}** | GET | Non | READ ONE : Lire la ressource identifiée |
| **films** | POST | JWT | CREATE ONE : Créer une ressource basée sur les données de la requête |
| **films/{id}** | DELETE | JWT | DELETE ONE : Effacer la ressource identifiée |
| **films/{id}** | PUT | JWT | UPDATE ONE : Replacer l'entièreté de la ressource par les données de la requête |

<br/>

## c.2) JWT authentification et autorisation : concepts généraux
Les JWT sont parfaits pour la création de RESTful APIs, car ils permettent de mettre en place 
un mécanisme d’authentification et autorisation « stateless » pour le backend.
<br/>

Le client va s’authentifier et donc obtenir un JWT généré par l’API lors de son enregistrement 
(**auths/register**) ou lors de son login (**auths/login**).

Le JWT généré par l’API contient 3 parties :
-	Un header : il est encodé en base64 indiquant l’algorithme de la signature du token.
-	Un payload : il est encodé en base64, il contient généralement des données permettant 
d’identifier l’utilisateur faisant la requête. Ces données ne sont pas secrètes 
(le payload n’est pas crypté !)
-	Une signature : elle est hachée selon l’algorithme spécifié dans le header. 
La signature permet de vérifier que le token n’a pas été modifié, et donc, 
de mettre en place un mécanisme d’autorisation d’accès aux opérations d’une API.

<br/>

Tout client souhaitant accéder à des opérations nécessitant une autorisation via JWT devra fournir 
un JWT dans le header de sa requête.
Pour ce faire, le client mémorisera généralement le JWT reçu lors de son authentification.
Typiquement, le JWT reçu par un client est enregistré dans le Web Storage de son browser ou dans un cookie.

<br/>

# <a id="sectionD"></a>d) Authentification et création de token JWT
## d.1) Ajout de la dépendance java-jwt
Tant pour la création que la vérification d’un token, nous utiliserons la librairie java-jwt :
https://github.com/auth0/java-jwt

Pour utiliser cette librairie, ajoutez une dépendance à **java-jwt** :
- Via IntelliJ : 
  - cliquez au sein de votre fichier **pom.xml** : **Code**, **Generate...**, **Dependency**
  - tapez : **java-jwt**
  - Installez les dépendances Maven en cliquant sur le bouton représentant "**Load Maven Changes**"
  - NB : si IntelliJ ne trouve pas votre dépendance, et que le numéro de version est mis en rouge
  dans **pom.xml**, vous pouvez probablement résoudre cela en faisant un clic droit sur votre 
  **pom.xml**, **Maven**, **Reload project**.
- Si vous n'avez pas IntelliJ, ajoutez cela au sein de **pom.xml** puis forcer l'installation des dépendances :
```markup
<dependency>
            <groupId>com.auth0</groupId>
            <artifactId>java-jwt</artifactId>
            <version>3.18.2</version>
</dependency>
```
<br/>

## d.2) Création du token JWT
### d.2.1) Introduction
Un token JWT doit être créé lors de l'authentification d'un utilisateur, au login ou à 
l'enregistrement de celui-ci.

Nous allons donc créer les opérations **login** et **register** pour des ressources de type **User**.
<br/>

Pour ce faire, voici les étapes que nous allons suivre :
- Ajout d'une propriété pour gérer le secret associé à la signature des tokens.
- Création d'une classe **User** qui va permettre de sérialiser les données du monde Java vers
le monde JSON.
- Création d'une classe **UserDataService** qui va permettre de gérer les données associées aux 
utilisateurs et qui va offrir les services d'accès aux données et la logique pour le **login** 
et le **register**.
- Création d'une Root Resource **AuthsResource** qui va s'occuper de gérer la présentation des 
ressources aux clients.
- Amélioration de la classe **Json** qui s'occupe de la persistance des données afin que l'on 
puisse parser n'importe quelle collection de données. 
- Test des opérations de **login** et **register**.

<br/>

### d.2.2) Propriété associée au secret utilisé pour la signature
Veuillez ajouter le secret permettant de signer les token au sein de votre fichier **dev.properties** :
```text {3}
BaseUri=http://localhost:8080/
DatabaseFilePath=db.json
JWTSecret=ilovefilms
```
<br/>

### d.2.3) Création des objets du domaine 
Veuillez ajouter la classe **User** au package **domain** :
```java
package be.vinci.domain;

public class User {

    private int id;

    private String login;

    private String password;

    public String getLogin() {
        return login;
    }

    public void setLogin(String login) {
        this.login = login;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public boolean checkPassword(String password) {
        return this.password.equals(password);
    }

    @Override
    public String toString() {
        return "{id:" + id + ", login:" + login + ", password:" + password + "}";
    }

}
```
<br/>

### d.2.4) Création du service de données associé aux utilisateurs
Nous souhaitons créer une classe **UserDataService** qui va permettre :
- de gérer les données associées aux utilisateurs ;
- d'offrir les cas d'utilisation **login** et **register**.

<br/>

Veuillez ajouter cette classe dans le package **services** :
```java numbered {16,57-58,84-85}
package be.vinci.services;

import be.vinci.domain.User;
import be.vinci.services.utils.Json;
import be.vinci.utils.Config;
import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.util.List;

public class UserDataService {
    private static final String COLLECTION_NAME = "users";
    private static Json<User> jsonDB = new Json<>();
    private final Algorithm jwtAlgorithm = Algorithm.HMAC256(Config.getProperty("JWTSecret"));
    private final ObjectMapper jsonMapper = new ObjectMapper();


    public List<User> getAll() {
        var items = jsonDB.parse(COLLECTION_NAME);
        return items;
    }


    public User getOne(int id) {
        var items = jsonDB.parse(COLLECTION_NAME);
        return items.stream().filter(item -> item.getId() == id).findAny().orElse(null);
    }

    public User getOne(String login) {
        var items = jsonDB.parse(COLLECTION_NAME);
        return items.stream().filter(item -> item.getLogin().equals(login)).findAny().orElse(null);
    }

    public User createOne(User item) {
        var items = jsonDB.parse(COLLECTION_NAME);
        item.setId(nextItemId());
        items.add(item);
        jsonDB.serialize(items, COLLECTION_NAME);
        return item;
    }

    public int nextItemId() {
        var items = jsonDB.parse(COLLECTION_NAME);
        if (items.size() == 0)
            return 1;
        return items.get(items.size() - 1).getId() + 1;
    }

    public ObjectNode login(String login, String password) {
        User user = getOne(login);
        if (user == null || !user.checkPassword(password))
            return null;
        String token;
        try {
            token = JWT.create().withIssuer("auth0")
                    .withClaim("user", user.getId()).sign(this.jwtAlgorithm);
            ObjectNode publicUser = jsonMapper.createObjectNode()
                    .put("token", token)
                    .put("id", user.getId())
                    .put("login", user.getLogin());
            return publicUser;

        } catch (Exception e) {
            System.out.println("Unable to create token");
            return null;
        }
    }

    public ObjectNode register(String login, String password) {
        User tempUser = getOne(login);
        if (tempUser != null) // the user already exists !
            return null;
        tempUser = new User();
        tempUser.setLogin(login);
        tempUser.setPassword(password);

        User user = createOne(tempUser);
        if (user == null)
            return null;
        String token;
        try {
            token = JWT.create().withIssuer("auth0")
                    .withClaim("user", user.getId()).sign(this.jwtAlgorithm);
            ObjectNode publicUser = jsonMapper.createObjectNode()
                    .put("token", token)
                    .put("id", user.getId())
                    .put("login", user.getLogin());
            return publicUser;

        } catch (Exception e) {
            System.out.println("Unable to create token");
            return null;
        }
    }

}
```
<br/>

Voici quelques explications concernant les token (d'autres explications portant sur les paramètres
de requête et la préparation des réponses seront données plus tard) :
- ligne 16 : on configure l'algorithme qui sera utilisé pour la signature du token sur base du 
secret se trouvant dans **dev.properties**
- lignes 57-58 & 84-85 : on génère un token et l'on ajoute juste l'**id** de l'utilisateur 
dans le payload.

<br/>

### d.2.4) Création de la Root Resource "User"
Veuillez ajouter cette classe dans le package **api** :
```java
package be.vinci.api;

import be.vinci.services.UserDataService;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import jakarta.inject.Singleton;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

@Singleton
@Path("/auths")
public class AuthsResource {

    private UserDataService myUserDataService = new UserDataService();

    @POST
    @Path("login")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public ObjectNode login(JsonNode json) {
        // Get and check credentials
        if (!json.hasNonNull("login") || !json.hasNonNull("password")) {
            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)
                    .entity("login or password required").type("text/plain").build());
        }
        String login = json.get("login").asText();
        String password = json.get("password").asText();

        // Try to login
        ObjectNode publicUser = myUserDataService.login(login, password);
        if (publicUser == null) {
            throw new WebApplicationException(Response.status(Response.Status.UNAUTHORIZED)
                    .entity("Login or password incorrect").type(MediaType.TEXT_PLAIN)
                    .build());
        }
        return publicUser;

    }

    @POST
    @Path("register")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public ObjectNode register(JsonNode json) {
        // Get and check credentials
        if (!json.hasNonNull("login") || !json.hasNonNull("password")) {
            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)
                    .entity("login or password required").type("text/plain").build());
        }
        String login = json.get("login").asText();
        String password = json.get("password").asText();

        // Try to login
        ObjectNode publicUser = myUserDataService.register(login, password);
        if (publicUser == null) {
            throw new WebApplicationException(Response.status(Response.Status.CONFLICT)
                    .entity("this resource already exists").type(MediaType.TEXT_PLAIN)
                    .build());
        }
        return publicUser;

    }

}
}
```
<br/>

Le service de données s'occupant des utilisateurs fournit, lors du login et du register, 
un **ObjectNode** qui contient l'id, le login et le token d'un utilisateur. 

<br/>

### d.2.5) Amélioration de la classe générique Json
La classe **Json** actuellement ne parse que des données vers le type **Film**.

Or on souhaiterait pouvoir charger n'importe quelle collection de données et écrire cela pour 
retourner une `List<T>` (une liste paramétrée vers le type passé à la classe générique **Json**) :
```java
return jsonMapper.readerForListOf(type).readValue(collection);
```
<br/>

On aimerait donc faire en sorte que **type**, dans le code donné ci-dessus, valent le type
passé à la classe générique. La difficulté pour y arriver, c'est que les "generics" en Java 
sont principalement déterminés à la compilation. Cela signifie que l'information est perdue à 
l'exécution (le type paramétré **T** un **Object**). 
Pour obtenir l'information associé au type passé à la classe générique, lors de l'exécution,
il faut ajouter un argument à une fonction.

Ici, on a choisi d'ajouter le type au constructor.
Voici donc les mises à jour de la classe **Json** en surligné : 
```java numbered {5-11,50}
public class Json<T> {
    private static final String DB_FILE_PATH = Config.getProperty("DatabaseFilePath");
    private static Path pathToDb = Paths.get(DB_FILE_PATH);
    private final static ObjectMapper jsonMapper = new ObjectMapper();
    private Class<T> type ;

    // Java generics are mostly compile time, this means that the type information is lost at runtime.
    // To get the type information at runtime you have to add it as an argument of the constructor.
    public Json(Class<T> type){
        this.type = type;
    }


    public void serialize(List<T> items, String collectionName) {
        try {
            // if no DB file, write a new collection to a new db file
            if (!Files.exists(pathToDb)) {
                // Create an object and add a JSON array as POJO, e.g. { items:[...]}
                ObjectNode newCollection = jsonMapper.createObjectNode().putPOJO(collectionName, items);
                jsonMapper.writeValue(pathToDb.toFile(), newCollection); // write the JSON Object in the DB file
                return;
            }
            // get all collections : can be read as generic JsonNode, if it can be Object or Array;
            JsonNode allCollections = jsonMapper.readTree(pathToDb.toFile()); // e.g. { users:[...], items:[...]}
            // remove current collection, e.g. remove the array of items
            if (allCollections.has(collectionName)) {
                ((ObjectNode) allCollections).remove(collectionName); //e.g. it leaves { users:[...]}
            }
            // Prepare a JSON array from the list of POJOs for the collection to be updated, e.g. [{"film1",...}, ...]
            ArrayNode updatedCollection = jsonMapper.valueToTree(items);
            // Add the JSON array in allCollections, e.g. : { users:[...], items:[...]}
            ((ObjectNode) allCollections).putArray(collectionName).addAll(updatedCollection);
            // write to the db file allCollections
            jsonMapper.writeValue(pathToDb.toFile(), allCollections);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public List<T> parse(String collectionName) {
        try {
            // get allCollections
            JsonNode node = jsonMapper.readTree(pathToDb.toFile());
            // accessing value of the specified field of an object node,
            // e.g. the JSON array within "items" field of { users:[...], items:[...]}
            JsonNode collection = node.get(collectionName);
            if (collection == null) // Send an empty list if there is not the requested collection
                return (List<T>) new ArrayList<T>();
            // convert the JsonNode to a List of POJOs & return it
            return jsonMapper.readerForListOf(type).readValue(collection);
        } catch (FileNotFoundException e) {
            return (List<T>) new ArrayList<T>(); // send an empty list if there is no db file
        } catch (IOException e) {
            e.printStackTrace();
            return (List<T>) new ArrayList<T>();
        }
    }

}

```
<br/>

Il ne reste plus qu'à modifier la création des instances de la classe **Json** pour passer 
l'information du type à l'exécution.

Veuillez mettre à jour cette ligne de **FilmDataService** :
```java {3}
public class FilmDataService {
    private static final String COLLECTION_NAME = "films";
    private static Json<Film> jsonDB = new Json<>(Film.class);
```
<br/>

Veuillez aussi mettre à jour cette ligne de **UserDataService** :
```java {3}
public class UserDataService {
    private static final String COLLECTION_NAME = "users";
    private static Json<User> jsonDB = new Json<>(User.class);
```
<br/>

### d.2.6) Test des opérations de login et de register
Veuillez tester les deux nouvelles opérations ajoutées.
Pour ce faire, à l'aide d'InteliJ, ajoutez le fichier **users.http** à votre module ou 
projet (dans le répertoire **requests** par exemple) avec ces requêtes :
```http-requests
### Register one default user
POST {{baseUrl}}/auths/register
Content-Type: application/json

{
  "login":"james",
  "password":"password"
}

### Login with default user credentials
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
  "login":"james",
  "password":"password"
}

### Register john
POST {{baseUrl}}/auths/register
Content-Type: application/json

{
  "login":"john",
  "password":"123"
}

### Login with John credentials
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
  "login":"john",
  "password":"123"
}
```
<br/>

Il ne vous reste plus qu'à exécuter votre RESTful API et exécuter les requêtes pour voir que 
l'API vous renvoie bien des tokens.

Si vous n'utilisez pas IntelliJ, mais plutôt VS Code, il suffit juste de rajouter la variable 
**baseUrl** à votre script **auths.http**.
<br/>

# <a id="sectionE"></a>e) Utilisation de jbcrypt pour gérer les passwords
Tant pour hasher un password que pour le vérifier, nous utiliserons la librairie jbcrype :
https://www.mindrot.org/projects/jBCrypt/

Pour utiliser cette librairie, ajoutez une dépendance à **jbcrypt** :
- Via IntelliJ : 
  - cliquez au sein de votre fichier **pom.xml** : **Code**, **Generate...**, **Dependency**
  - tapez : **jbcrypt**
  - Installez les dépendances Maven en cliquant sur le bouton représentant "**Load Maven Changes**"
  - NB : si IntelliJ ne trouve pas votre dépendance, et que le numéro de version est mis en rouge
  dans **pom.xml**, vous pouvez probablement résoudre cela en faisant un clic droit sur votre 
  **pom.xml**, **Maven**, **Reload project**.
- Si vous n'avez pas IntelliJ, ajoutez cela au sein de **pom.xml** puis forcer l'installation des dépendances :
```markup
<dependency>
            <groupId>org.mindrot</groupId>
            <artifactId>jbcrypt</artifactId>
            <version>0.4</version>
</dependency>
```
<br/>

Nous allons mettre à jour la classe **User** afin d'offrir la fonction **hashPassword** et
mettre à jour la fonction **checkPassword** : 
```java
public boolean checkPassword(String password) {
    return BCrypt.checkpw(password, this.password);
}

public String hashPassword(String password) {
    return BCrypt.hashpw(password, BCrypt.gensalt());
}
```
<br/>

Attention, maintenant que nous utilisons les passwords hachés, il faut supprimer l'ancienne base 
de donnée des utilisateurs. Vous devez soit effacer la collection **users** du fichier **db.json**,
soit vous pouvez aussi directement effacer le fichier **db.json**.
<br/>

Il ne reste plus qu'à modifier légérement **UserDataService** afin d'enregistrer les passwords 
hachés : veuillez mettre à jour la ligne surlignée de la méthode **register** :
```java {7}
public ObjectNode register(String login, String password) {
        User tempUser = getOne(login);
        if (tempUser != null) // the user already exists !
            return null;
        tempUser = new User();
        tempUser.setLogin(login);
        tempUser.setPassword(tempUser.hashPassword(password));
```
<br/>

# <a id="sectionF"></a>f) Autorisation JWT, filtres, providers & "Name binding"
## f.1) Vérification d'un token : concepts généraux
La vérification d’un token n’est nécessaire que pour les opérations sur les ressources 
qui doivent être protégées (ou autorisées).

Le code générique pour vérifier un token est donné ici :
https://github.com/auth0/java-jwt#verify-a-token.
<br/>

Il serait peu intéressant de devoir réimplémenter ce code pour chaque opération nécessitant 
une autorisation JWT.
<br/>

Ce que nous souhaitons, c’est :
- Pouvoir annoter chaque méthode d’une Root Resource devant être autorisée par JWT : 
nous choisissons l’annotation **@Authorize** pour notre API de gestion de films ;
- Appeler le morceau de code s’occupant de vérifier un JWT pour chaque méthode annotée de **@Authorize** :
    - si le JWT reçu au sein du header de la requête est OK, nous nous occupons de charger 
    l’utilisateur ayant fait la requête dans un container associé à la requête du client, 
    via la clé "user" ; ensuite, le code de la méthode annotée par **@Authorize** est exécuté ;
    - si le JWT reçu au sein du header n’est pas vérifié avec succès, nous envoyons un code 
    d’erreur au client ; le code de la méthode annotée par **@Authorize** ne sera donc pas exécuté.

<br/>

NB : Pour certains d'entre vous, cela pourrait vous rappellera la création et l’utilisation 
d’un middleware « authorize » dans le monde de Node.js / Express.
<br/>

Au sein d’une application JAX-RS, les filtres « serveurs » permettent de modifier 
les requêtes ou les réponses, soit pour toutes les requêtes, soit pour seulement certaines 
méthodes… 

La suite fournit un résumé de comment mettre en place un filtre « serveur » pour toutes 
les méthodes contenant une annotation personnelle, **@Authorize** dans la démo.
<br/>

## f.2) Filtres, providers & « Name binding »
Il est possible de créer toutes sortes de filtres pour modifier soit les requêtes,
soit les réponses d’une application JAX-RS. 
<br/>

Si vous souhaitez des détails en plus du résumé présenté par la suite, les filtres sont expliqués dans le manuel de Jersey : 
https://eclipse-ee4j.github.io/jersey.github.io/documentation/latest3x/filters-and-interceptors.html
<br/>

Les filtres « serveurs » sont illustré au sein de cette section via la mise en place 
d’un filtre de requêtes permettant principalement de filtrer toutes les requêtes qui 
ne seraient pas autorisées (lorsque le JWT reçu n’est pas valide).
<br/>

Afin d’exécuter le traitement d’autorisation JWT pour chaque méthode annotée de **@Authorize**, 
nous allons utiliser un objet de type « filtre de requête » qui hérite de **ContainerRequestFilter**.
<br/>

Veuillez ajouter un package **filters** au sein du package **api** et y créer la classe 
**AuthorizationRequestFilter** :
```java
package be.vinci.api.filters;

import java.io.IOException;

import be.vinci.domain.User;
import be.vinci.services.UserDataService;
import be.vinci.utils.Config;
import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.auth0.jwt.interfaces.JWTVerifier;
import jakarta.inject.Singleton;
import jakarta.ws.rs.WebApplicationException;
import jakarta.ws.rs.container.ContainerRequestContext;
import jakarta.ws.rs.container.ContainerRequestFilter;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.Status;
import jakarta.ws.rs.ext.Provider;

@Singleton
@Provider
@Authorize
public class AuthorizationRequestFilter implements ContainerRequestFilter {
    private final Algorithm jwtAlgorithm = Algorithm.HMAC256(Config.getProperty("JWTSecret"));
    private final JWTVerifier jwtVerifier = JWT.require(this.jwtAlgorithm).withIssuer("auth0").build();
    private UserDataService myUserDataService = new UserDataService();

    @Override
    public void filter(ContainerRequestContext requestContext) throws IOException {
        String token = requestContext.getHeaderString("Authorization");
        if (token == null) {
            requestContext.abortWith(Response.status(Response.Status.UNAUTHORIZED)
                    .entity("A token is needed to access this resource").build());
        } else {
            DecodedJWT decodedToken = null;
            try {
                decodedToken = this.jwtVerifier.verify(token);
            } catch (Exception e) {
                throw new WebApplicationException(Response.status(Status.UNAUTHORIZED)
                        .entity("Malformed token : " + e.getMessage()).type("text/plain").build());
            }
            User authenticatedUser = myUserDataService.getOne(decodedToken.getClaim("user").asInt());
            if (authenticatedUser == null) {
                requestContext.abortWith(Response.status(Status.FORBIDDEN)
                        .entity("You are forbidden to access this resource").build());
            }

            requestContext.setProperty("user",
                    myUserDataService.getOne(decodedToken.getClaim("user").asInt()));
        }
    }

}
```
<br/>

**AuthorizationRequestFilter** va vérifier le JWT : 
- S’il n’est pas OK, la requête est « avortée » en appelant **abortWith** et en 
fournissant le code d’erreur ainsi qu’un message d’erreur au client. 
- Si le JWT est OK, le claim "user" mis dans le payload du JWT, 
qui en fait est l’id de l’utilisateur, est utilisé pour ajouter l’utilisateur à la requête 
( l'utilisateur est récupéré en faisant appel à la méthode **getOne** du service des données 
des utilisateurs) sous la clé **user**. 
Ensuite, la méthode de la ressource annotée par **@Authorize** est exécutée, 
afin de préparer la réponse au client.
<br/>

La notion de provider est définie dans la spécification de JAX-RS : 
https://jakarta.ee/specifications/restful-ws/3.0/jakarta-restful-ws-spec-3.0.html#providers 
<br/>

En résumé, un provider permet de filtrer les requêtes, convertir des représentations 
(XML, JSON…) vers des objets Java, mapper des exceptions à des réponses… 

Il existe de nombreux providers prédéfinis qui sont fournis dans Jersey. 

L’annotation **@Provider** permet de fournir notre propre implémentation d’un provider, 
de la rendre disponible à l’exécution à notre application JAX-RS.
<br/>

Un filtre peut être lié à un nom, ce que l’on appelle « **Name binding** ». 

A l’exécution d’une application JAX-RS, on pourra spécifier que le filtre sera exécuté 
seulement pour certaines méthodes.

NB : les filtres peuvent ne pas être limités, on les appelle alors filtre globaux.
<br/>

Nous allons définir une annotation de type « **Name binding** » via **@NameBinding**.

Veuillez créer l'annotation **Authorize** au sein du package **filters** :
```java
package be.vinci.api.filters;

import jakarta.ws.rs.NameBinding;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@NameBinding
@Retention(RetentionPolicy.RUNTIME)
public @interface Authorize {
}
```
<br/>

C’est grâce à cette annotation qui a été définie que **AuthorizationRequestFilter** 
ne s’exécutera que pour les méthodes annotées de **@Authorize**.
<br/>

Au sein de **FilmResource**, il nous reste donc à annoter les opérations d'écriture de notre API de gestion de films afin de 
les protéger par une autorisation JWT :
```java numbered {43,54,70}
package be.vinci.api;

import be.vinci.api.filters.Authorize;
import be.vinci.domain.Film;
import be.vinci.domain.User;
import be.vinci.services.FilmDataService;
import jakarta.inject.Singleton;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import org.glassfish.jersey.server.ContainerRequest;

import java.util.List;

@Singleton
@Path("films")
public class FilmResource {

    private FilmDataService myFilmDataService = new FilmDataService();

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public List<Film> getAll(@DefaultValue("-1") @QueryParam("minimum-duration") int minimumDuration) {
        return myFilmDataService.getAll(minimumDuration);
    }


    @GET
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Film getOne(@PathParam("id") int id) {
        Film filmFound = myFilmDataService.getOne(id);
        if (filmFound == null)
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity("Ressource not found").type("text/plain").build());
        return filmFound;
    }

    @POST
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    @Authorize
    public Film createOne(Film film, @Context ContainerRequest request) {
        if (film == null || film.getTitle() == null || film.getTitle().isBlank())
            throw new WebApplicationException(
                    Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory info").type("text/plain").build());
        return myFilmDataService.createOne(film);
    }

    @DELETE
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    @Authorize
    public Film deleteOne(@PathParam("id") int id) {
        if (id == 0) // default value of an integer => has not been initialized
            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory id info")
                    .type("text/plain").build());
        Film deletedFilm = myFilmDataService.deleteOne(id);
        if (deletedFilm == null)
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity("Ressource not found").type("text/plain").build());
        return deletedFilm;
    }

    @PUT
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    @Authorize
    public Film updateOne(Film film, @PathParam("id") int id) {
        if (id == 0 || film == null || film.getTitle() == null || film.getTitle().isBlank())
            throw new WebApplicationException(
                    Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory info").type("text/plain").build());
        Film updatedFilm = myFilmDataService.updateOne(film, id);
        if (updatedFilm == null)
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity("Ressource not found").type("text/plain").build());
        return updatedFilm;
    }


}
```
<br/>


Comment peut-on récupérer l’objet **user** mis dans la requête par le 
**AuthorizationRequestFilter** ?
<br/>

Voici un exemple en modifiant la méthode **createOne** de **FilmResource** :
```java {5-7}
@POST
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@Authorize
public Film createOne(Film film, @Context ContainerRequest request) {
    User authenticatedUser = (User) request.getProperty("user");
    System.out.println("A new film is added by " + authenticatedUser.getLogin() );
    if (film == null || film.getTitle() == null || film.getTitle().isBlank())
        throw new WebApplicationException(
                Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory info").type("text/plain").build());
    return myFilmDataService.createOne(film);
}
```
<br/>

C’est l’appel de **getProperty** sur un **ContainerRequest** qui permet de récupérer 
l’objet préparé lors du traitement d’autorisation JWT (fait dans le filtre).
<br/>

# <a id="sectionG"></a>g) Envoi des requêtes à son API et JWT
## g.1) Test de son API avec JWT
Dans le cadre de ce cours, vous ne devez pas développer de frontend (par exemple en HTML / 
JavaScript / CSS) pour tester vos APIs. Cela prendrait trop de temps. 

Nous utilisons donc des clients légers permettant de faire des requêtes à nos APIs.

Comme nous vous encourageons à utiliser IntelliJ pour développer votre code Java, il est probablement 
plus aisé de rester au sein du même environnement de développement en utilisant le client HTTP 
d'IntelliJ.
<br/>

## g.2) HTTP Client d'IntelliJ avec des JWT
IntelliJ permet d'ajouter des scripts associés aux réponses de cette façon :
```text
GET host/api/test

> {%
// Response Handler Script
...
%}
```
<br/>

Les scripts gérant les réponses aux requêtes peuvent accéder à deux objets :
- **client** : permet d'enregistrer des données de session dans **client.global**.
Chaque variable que l'on sauve dans **client.global** en tant que **variable_name**, 
en appelant la méthode **set**, sera accessible dans les requêtes futures via **{{variable_name}}**.
- **response** : contient les infos de la réponse à la requête (type, status, body...)

<br/>

Voici le code permettant de tester l'API de gestion des films :

```text
### Read All films
GET {{baseUrl}}/films

### Login the default user
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
  "login":"james",
  "password":"password"
}

> {%
client.global.set("jamesToken", response.body.token);
%}


### Create One film
POST {{baseUrl}}/films
Content-Type: application/json
Authorization: {{jamesToken}}

{
  "title": "Venom: Let There Be Carnage",
  "duration": 9,
  "budget": 110,
  "link": "https://en.wikipedia.org/wiki/Venom:_Let_There_Be_Carnage"
}

### Delete One film
DELETE {{baseUrl}}/films/5
Authorization: {{jamesToken}}

### Update One film
PUT {{baseUrl}}/films/4
Content-Type: application/json
Authorization: {{jamesToken}}

{
  "title": "Venom: Let There Be Carnage",
  "duration": 97,
  "budget": 110,
  "link": "https://en.wikipedia.org/wiki/Venom:_Let_There_Be_Carnage"
}

### Create One film with dangerous characters
POST {{baseUrl}}/films
Content-Type: application/json
Authorization: {{jamesToken}}

{
  "title": "<img src=\"#\" onerror=\"alert('You have been hacked !')\">",
  "duration": 9,
  "budget": 110,
  "link": "https://en.wikipedia.org/wiki/Venom:_Let_There_Be_Carnage"
}
```

<br/>

Plus d'information sur la gestion des réponses aux requêtes via le client HTTP d'IntelliJ :
https://www.jetbrains.com/help/idea/http-client-in-product-code-editor.html#using-response-handler-scripts

<br/>

## g.3) REST Client sous VS Code & JWT
Quelques notions pour utiliser REST Client avec des JWT :
- Il est possible de créer des « **Request Variables** » afin de récupérer la réponse associée 
à une requête au sein d’une variable.
- On va donc pouvoir récupérer le token, suite à une requête d’authentification, 
au sein d’une « **Request Variable** », pour ensuite fournir ce token dans le 
« **Authorization header** » de toutes les requêtes demandant une autorisation JWT.
<br/>

Voici le script permettant de tester les opérations sur les films :

```http-requests
@baseUrl = http://localhost:8080

### Login the default user & define a Request Variable
# @name james
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
  "login":"james",
  "password":"password"
}
### get the james' token in a File Variable
@jamesToken = {{james.response.body.token}}

### Create One film
POST {{baseUrl}}/films
Content-Type: application/json
Authorization: {{jamesToken}}

{
  "title" : "Venom: Let There Be Carnage",
  "duration" : 97,
  "budget" : 110,
  "link" : "https://en.wikipedia.org/wiki/Venom:_Let_There_Be_Carnage"
}

### Read All films
GET {{baseUrl}}/films

### Delete One film
DELETE {{baseUrl}}/films/5
Authorization: {{admin.response.body.token}}

### Update One film
PUT {{baseUrl}}/films/4
Content-Type: application/json
Authorization: {{jamesToken}}

{
  "title" : "Venom: Let There Be Carnage",
  "duration" : 97,
  "budget" : 110,
  "link" : "https://en.wikipedia.org/wiki/Venom:_Let_There_Be_Carnage"
}
```
<br/>

Plus de détails sur REST Client et ses fonctionnalités : 
https://github.com/Huachao/vscode-restclient
<br/>

# <a id="sectionH"></a>h) Gestion des requêtes contenant des objets JSON quelconques
## h.1) Introduction
Dans le cadre du module 1, nous avons vu les moyens principaux de gérer des requêtes. 

Pour ce module-ci, nous avons été en contact avec du code permettant :
- de récupérer des informations JSON du body d’une requête sans passer par un POJO, 
mais en utilisant un **JsonNode**. 
- de retrouver le contexte d'une requête.
<br/>

Nous allons maintenant expliquer les concepts associés.
<br/>

## h.2) Récupération des paramètres d'une requête d'un objet quelconque
Nous allons souvent souhaiter récupérer des données qui ont été envoyées au format 
JSON sein du body d’une requête client.
<br/>

Dans le cas où ces données ne correspondent pas à un POJO, nous pouvons utiliser 
un paramètre de type **JsonNode**, et récupérer les champs JSON via la méthode **get**.
<br/>

Admettons qu’une requête cliente envoie ce JSON : 
```json
{
    "login":"james",
    "password":"password"
}
```
<br/>

La méthode **login** de la classe **AuthsResource** permet de récupérer cet objet JSON 
et de le parser au sein de l’argument **json** :
```java {5,11-12}
@POST
@Path("login")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public ObjectNode login(JsonNode json) {
    // Get and check credentials
    if (!json.hasNonNull("login") || !json.hasNonNull("password")) {
        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)
                .entity("login or password required").type("text/plain").build());
    }
    String login = json.get("login").asText();
    String password = json.get("password").asText();
```
<br/>

Il ne faut pas oublier de préciser le type MIME de la requête qui sera consommée 
par la méthode, ici : **@Consumes(MediaType.APPLICATION_JSON)**.
<br/>

NB : Tout cela est possible car Jackson est bien configuré au sein de 
notre application JAX-RS.
<br/>

## h.3) Contexte et @Context
JAX-RS fournit un moyen simple de bénéficier d’informations associées au contexte du 
déploiement d’une application et du contexte de requêtes individuelles. 

Ces informations sont disponibles pour les sous-classes d’Application, Root Resource Classes 
et les providers. C’est l’annotation **@Context** qui permet, par exemple, d’injecter 
un provider au sein d’une variable (argument d’une méthode ou champs d’une classe).
<br/>

Dans le code de la méthode **createOne** de **FilmResource**, c’est grâce à **@Context** 
que l’on peut récupérer le contenu de la requête qui a été filtrée par 
**AuthorizationRequestFilter** :
```java {5}
@POST
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@Authorize
public Film createOne(Film film, @Context ContainerRequest request) {
    User authenticatedUser = (User) request.getProperty("user");
    System.out.println("A new film is added by " + authenticatedUser.getLogin() );
```
<br/>

# <a id="sectionI"></a>i) Gestion des réponses et sérialisation d’objets JSON quelconques
## i.1) Introduction
Dans le cadre du module 1, nous avons vu les moyens principaux de gérer des réponses.
Nous renvoyions toujours des POJOs ou des listes de POJOs. 

Pour ce module-ci, nous avons été en contact avec du code permettant de sérialiser 
des informations et les renvoyer au client sans devoir passer par un POJO, 
mais en créant ses propres objets JSON.
<br/>

## i.2) Sérialiser et renvoyer des objets JSON quelconques
Dans le cas où des données à renvoyer à un client ne correspondent pas à un POJO, 
nous pouvons créer en Java du Json via :
- **JsonNode** si cela peut être la représentation d'un objet en JSON (**ObjectNode**) 
ou d'un tableau en JSON (**ArrayNode**)
- **ObjectNode** pour la représentation d'un objet en JSON
- **ArrayNode**  pour la représentation d'un tableau en JSON

<br/>

Admettons que nous souhaitons construire une réponse JSON de ce type : 
```json
{
  "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJhdXRoMCIsInVzZXIiOjF9.JX5Xnp4KDvpkderjcv2W1TmCgwklKpRDIw3vheDSoNg",
  "id": 1,
  "login": "james"
}
```
<br/>

Dans la méthode **login** de la classe **AuthsResource**, voici le code permettant 
de renvoyer une représentation JSON de cet objet via un **ObjectNode** :
```java numbered {3,8,18,24}
public class AuthsResource {
    //...
    private final ObjectMapper jsonMapper = new ObjectMapper();
    //...
    @POST
    @Path("login")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public ObjectNode login(JsonNode json) {
        // Get and check credentials
        if (!json.hasNonNull("login") || !json.hasNonNull("password")) {
            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)
                    .entity("login or password required").type("text/plain").build());
        }
        String login = json.get("login").asText();
        String password = json.get("password").asText();
        // Try to login
        ObjectNode publicUser = myUserDataService.login(login, password);
        if (publicUser == null) {
            throw new WebApplicationException(Response.status(Response.Status.UNAUTHORIZED)
                    .entity("Login or password incorrect").type(MediaType.TEXT_PLAIN)
                    .build());
        }
        return publicUser;
    }
```
<br/>

C'est donc la méthode **login** de **UserDataService** qui crée la représentation JSON 
d'un objet contenant un **token**, un **id** et un **login** comme propriétés. 
Le code permettant de créer une représentation de cet objet JSON utilise un 
**ObjectMapper** permettant de créer un **ObjectNode** :
```java numbered {9-13}
public ObjectNode login(String login, String password) {
    User user = getOne(login);
    if (user == null || !user.checkPassword(password))
        return null;
    String token;
    try {
        token = JWT.create().withIssuer("auth0")
                .withClaim("user", user.getId()).sign(this.jwtAlgorithm);
        ObjectNode publicUser = jsonMapper.createObjectNode()
                .put("token", token)
                .put("id", user.getId())
                .put("login", user.getLogin());
        return publicUser;

    } catch (Exception e) {
        System.out.println("Unable to create token");
        return null;
    }
}
```
<br/>

La méthode **put** permet d’ajouter des champs à un objet de type **ObjecNode**.
Nous pouvons ajouter autant de champs que nécessaire à l’objet JSON qui sera 
sérialisé et renvoyé au client via une Root Resource (**AuthsResource** dans notre exemple).

<br/>

**Code du tutoriel** : si vous souhaitez directement accéder au code de la fin du tutoriel de 
création d'une API de gestion de films pour ce module 2 : 
https://github.com/e-vinci/baja-demos/tree/main/films-api-module2

<br/>

# <a id="sectionJ"></a>j) Exercice 2.1
Peut-être avez-vous déjà entendu parler de cette mode montante dans le Web 
qu’est la JAMstack ?
<br/>

Nous souhaitons développer un Headless CMS, c’est-à-dire un outil permettant 
de créer du contenu, très souvent utilisé dans le cadre de sites JAMstack.

Un Headless CMS fournira une interface web pour créer du contenu (ou des données), 
ainsi qu’une RESTful API mettant à disposition ce contenu.
<br/>

L’Headless CMS que nous souhaitons développer doit permettre de créer le contenu 
associé à un blog.

Un blog sera structuré en pages. Une page aura un id, un titre, un URI, un contenu, 
un auteur ainsi qu’un statut de publication.

Le statut de publication d’une page peut actuellement prendre comme valeur :
- « hidden »
- « published »

<br/>

Seul un utilisateur authentifié pourra lire, créer, modifier ou supprimer des pages.
<br/>

La modification d’une page, tout comme la suppression d’une page ne pourra se faire 
que par son auteur.
<br/>

L’ajout ou la modification d’une page ne sera possible que si le statut de publication 
donné correspond à un des deux statuts actuels (« hidden ou « published »). 
Sinon un message d’erreur devra être renvoyé.
<br/>

La lecture d’une page, ou de toutes les pages, pourra être réalisée par n’importe
quel utilisateur authentifié pour les pages dont le statut vaut « published ».
<br/>

Pour les pages dont le statut vaut « hidden », seul leur auteur authentifié pourra les lire.
<br/>

Lorsque vous renvoyer les données associées à une page, il est acceptable, à ce stade-ci, 
d'inclure le password dans la réponse faite au client. 
<br/>

Il est aussi acceptable à ce stade-ci, lorsque vous devez renvoyer une erreur à un client, de simplement 
renvoyer un code d'erreur (sans mettre de message dans le body de la réponse).
<br/>

Veuillez développer une application JAX-RS mettant à disposition les opérations 
décrites ci-dessus.
<br/>

Dans un premier temps, veuillez formaliser les opérations associées à vos RESTful 
APIs sous forme d’un tableau dans un fichier **README.md**. 

Votre tableau doit reprendre les conventions REST présentées au point 
[c) Rappel de conventions sur les RESTful APIs, authentification & autorisation](/modules/2#sectionC).
<br/>

Comment créer un tableau dans un fichier Markdown  ? 
Deux options :
- Soit vous utiliser des '**|**' pour délimiter les cellules et des '**|---|**' pour séparer 
les headers du corps du tableau. 
Voici un exemple pour l'API de films :
```text
| URI | Méthode HTTP | Auths? | Opération |
|---|---|---|---|
| **films** | GET | Non | READ ALL : Lire toutes les ressources de la collection |
| **films?minimumduration=value** | GET | Non | READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donné |
| **films/{id}** | GET | Non | READ ONE : Lire la ressource identifiée |
| **films** | POST | JWT | CREATE ONE : Créer une ressource basée sur les données de la requête |
| **films/{id}** | DELETE | JWT | DELETE ONE : Effacer la ressource identifiée |
| **films/{id}** | PUT | JWT | UPDATE ONE : Replacer l'entièreté de la ressource par les données de la requête |
```
- Soit c’est simplement un tableau HTML (`<table>`).

<br/>

Lors de l’implémentation de vos RESTful APIs, veuillez tester toutes les 
méthodes offertes par votre application JAX-RS à l’aide d'un client léger (HTTP client d'IntelliJ 
ou Rest Client de VS Code).
<br/>

Les ressources doivent persister au format JSON et vous devez échapper les caractères dangereux.
<br/>

Veuillez partir d'un archetype Maven comme décrit au point 
[Module 1 : b) Création d’une première application sur base d’un Archetype Maven](/modules/1#sectionB).

Veuillez intégrer à votre application les fichiers utiles de la démo 
https://github.com/e-vinci/baja-demos/tree/main/films-api-module2 présentée dans ce module-ci, 
principalement : **pom.xml**, **Authorize**, **AuthorizationRequestFilter**, **Config**, **AuthsResource**, **UserDataService**

<br/>

Optionnel : vous souhaitez rapidement découvrir les principes d’une architecture 
Web associée à la JAMstack ? https://jamstack.wtf/ 
<br/>

Optionnel : si vous souhaitez découvrir le format Markdown, notamment très souvent utilisé 
dans certains sites JAMstack (source des données pour certains Headless CMS) : 
https://www.markdownguide.org/basic-syntax/
<br/>

**Challenges** : 
- **N°1** : Modifiez les autorisations au niveau des opérations de lecture (en gras pour la modification) : 
la lecture d’une page, ou de toutes les pages, pourra être réalisée par n’importe 
quel utilisateur **anonyme ou authentifié** pour les pages dont le statut vaut « published ».
Pour les pages dont le statut vaut « hidden », seul leur auteur authentifié pourra les lire.
- **N°2** : lorsqu'un utilisateur tente d'effacer ou modifier une page dont il n'est pas l'auteur,
renvoyer un code d'erreur approprié au client.
- **N°3** : Si vous ne l'avez pas déjà fait, trouvez une façon de ne pas inclure le password lors de la sérialisation de celui-ci 
dans une page (via l'auteur de la page). Attention, le password doit toujours être sérialisé 
lors de l'enregistrement d'un utilisateur.


<br/>