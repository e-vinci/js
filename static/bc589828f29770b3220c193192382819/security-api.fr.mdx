---
title: "S√©curisation API"
description: "S√©curisation d'une RESTful API"
---

# b) S√©curisation d'une RESTful API

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part4"> Partie 4 </PathViewerItem>
    <PathViewerItem selected> b) S√©curitsation d'une RESTful API </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Protection contre les attaques XSS </InternalPageMenuItem>
  <InternalPageMenuItem> S√©curisation des passwords </InternalPageMenuItem>
  <InternalPageMenuItem> Projet 4.2 : S√©curisation d'API </InternalPageMenuItem>
  <InternalPageMenuItem> üç¨ Authentification & autorisation JWT √† l'aide de cookies </InternalPageMenuItem> 
</InternalPageMenu>

<div className="card card__simple-youtube-container">
    <YoutubeImage src="https://youtu.be/KsJ-11PcSp4" />
</div>

La s√©curisation d'API est une probl√©matique complexe.  
Nous n'allons pas aller dans les d√©tails de cette probl√©matique, juste offrir une solution √† deux cas simples √† traiter.

# <InternalPageTitle> Protection contre les attaques XSS </InternalPageTitle>

## Une attaque XSS, c'est quoi ?

Les attaques **XSS**, ou **Cross-Site Scripting**, sont un type d'injection de scripts malicieux dans une application web.

Imaginez le forum web d'une banque et ce sc√©nario :

<ScrollableImage name="xss.png" minWidth="500px" maxWidth="700px" />

L'API de la banque permet d'enregistrer des messages qui sont associ√©s √† des forums sur lesquels leurs clients peuvent poster des messages.  
Si l'API de la banque √©tait mal s√©curis√©e et qu'elle permettait d'enregistrer n'importe quels types d'information en tant que "messages" du forum, il serait possible √† un attaquant d'injecter du JS malicieux dans l'API.  
Plus tard, lors de l'affichage des messages par le forum de la banque (**`https://forum.my-bank.com`**), le JS malicieux pourrait s'ex√©cuter dans le browser de n'importe quel utilisateur.  
Vous avez vu que via du JS, on peut envoyer de l'information n'importe o√π, notamment √† l'aide de **`fetch`**. Ce qui permettrait donc √† un hacker, via son script malicieux, d'envoyer des cookies contenant des infos sensibles √† son API malicieuse, en vue de futures attaques encore plus diaboliques, comme notamment vider le compte en banque d'utilisateurs.

La protection contre des attaques XSS se fait √† diff√©rents niveaux. Ca n'est pas l'objet de ce cours de voir cela en d√©tails, mais nous verrons un technique simple pour √©viter certaines attaques.

## R√©aliser une attaque XSS
Nous allons maintenant r√©aliser une attaque XSS sur le site de la pizzeria.

Veuillez lancer le frontend [jwt-fetch-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/jwt-fetch) (nous allons le d√©velopper tout prochainement, vous pouvez simplement en faire une copie temporaire, l'installer et l'ex√©cuter) et le backend **`api-auths`** du site de la pizzeria (**`/web2/tutorials/pizzeria/api/auths`** ou en cas de soucis : [api-auths](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/auths)).

Evidemment, un hackeur, pour tenter l'attaque XSS, doit d'abord trouver un moyen d'usurper la session d'**`admin`**. Nous ne verrons pas dans ce cours le genre d'attaques qui permettrait de le faire. Nous allons consid√©rer que cette premi√®re attaque est r√©ussie et nous allons prendre le r√¥le d'un hackeur pouvant acc√©der au compte **`admin`**.

Veuillez vous loguer √† l'aide du compte **`admin`** (et le password **`admin`**).  
Veuillez vous rendre sur la page **`Add a pizza`**.

Pour le titre de la pizza, vous pouvez ajouter n'importe quoi.
Dans le contenu de la pizza, veuillez ajouter cela et soumettre : 

```text
<img src="#" onerror="alert('You have been hacked !')">
```

En fait, nous avons ajout√© une balise **`img`** contenant du inline JS. **`onerror`** est un gestionnaire d'√©v√©nements qui sera d'office appel√© car la source (**`src="#"`** ) donn√© √† **`img`** n'est pas une image.

Maintenant, tout utilisateur connect√© ou pas qui se loguera sur le site va ex√©cuter ce script "malicieux". Il verra le pop-up appara√Ætre avec le message *"You have been hacked !"*.  
En effet, le menu des pizzas, tel qu'il est construit, est bas√© sur toutes les ressources de type "pizzas" renvoy√©es par l'API, dont une des pizzas contient le JS malicieux qui est ex√©cut√© dans une cellule de la table via ce code de la **`HomePage`** de l'IHM :
```js highlighting="7"
function getAllTableLinesAsString(menu) {
  let pizzaTableLines = '';

  menu?.forEach((pizza) => {
    pizzaTableLines += `<tr>
      <td>${pizza.title}</td>
      <td>${pizza.content}</td>
    </tr>`;
  });

  return pizzaTableLines;
}
```

## Emp√™cher les attaques XSS

Par rapport √† l'attaque pr√©c√©dente, le plus simple pour prot√©ger de l'attaque pourrait √™tre de faire en sorte que l'application cliente n'interpr√®te pas d'HTML / JS / CSS envoy√© par l'API.

Ici, dans la **`HomePage`**, on utilise la propri√©t√© **`innerHTML`** d'une **`td`**. Ainsi, l'HTML et l'inline JS associ√© est ex√©cut√©. Si l'on utilisais la propri√©t√© **`innerText`** des **`td`**, alors, ni l'HTML et le JS serait interpr√©t√© par le browser, et donc pas de possibilit√© de script malicieux au niveau de la **`HomePage`**.

Oui, mais si nous allions vers cette solution, cela serait probl√©matique si nous souhaitions r√©ellement d√©velopper plusieurs applications clientes, il faudrait toujours faire attention √† cette contrainte.

D√®s lors, nous allons pr√©f√©rer la solution o√π nous s√©curisons l'API. Ainsi, peu importe l'application cliente d√©velopp√©e, il devrait y avoir moins d'angles d'attaques.

Au niveau de l'API, nous allons √©chapper les caract√®res dangereux, principalement **`"`**, **`'`**, **`&`**, **`<`**, **`>`**.

Nous allons utiliser la librairie **[escape-html](https://www.npmjs.com/package/escape-html)** sous Node.js √©chappant les string pour une utilisation des string transform√©es en HTML.

Pour ce nouveau tutoriel, nous allons continuer le d√©veloppement de l'API [api-auths](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/auths) et la s√©curiser.

Au sein de votre repo **`web2`**, veuillez cr√©er le projet nomm√© **`/web2/tutorials/pizzeria/api/safe`** sur base d'un copi√©/coll√© de **`/web2/tutorials/pizzeria/api/auths`** (ou [api-auths](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/auths)).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**`/web2/tutorials/pizzeria/api/safe`**.

Veuillez installer la librairie **`escape-html`** au sein de votre projet **`safe`** :
```bash
npm i escape-html
```

Nous allons supprimer, s'il existe, le fichier reprenant le code malicieux introduit pr√©c√©demment : veuillez supprimer le fichier **`/data/pizzas.json`**.

Nous allons mettre √† jour le mod√®le de pizzas pour √©chapper les caract√®res dangereux.
Veuillez modifier **`/models/pizzas.js`** :
```js highlighting="1,9-10"
const escape = require('escape-html');
// other bits of code

function createOnePizza(title, content) {
  const pizzas = parse(jsonDbPath, defaultPizzas);

  const createdPizza = {
    id: getNextId(),
    title: escape(title),
    content: escape(content),
  };

  pizzas.push(createdPizza);

  serialize(jsonDbPath, pizzas);

  return createdPizza;
}
```

Nous allons maintenant tester si tout est r√©gl√© au niveau de l'attaque XSS.  
Dans votre frontend temporaire ([jwt-fetch](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/jwt-fetch)), veuillez vous loguer √† l'aide du compte **`admin`** (et le password **`admin`**).  
Veuillez vous rendre sur la page **`Add a pizza`**.

Comme pr√©c√©demment : 
- Pour le titre de la pizza, vous pouvez ajouter n'importe quoi.
- Dans le contenu de la pizza, veuillez ajouter cela et soumettre : 

``` text
<img src="#" onerror="alert('You have been hacked !')">
```

Maintenant, tout utilisateur connect√© verra simplement appara√Ætre, quand il affiche la **`HomePage`**, le menu des pizzas avec :

<ScrollableImage name="hacked.png" minWidth="500px" maxWidth="744px" />

Il n'y a plus de code JavaScript malicieux qui peut s'ex√©cuter c√¥t√© client üéâ !

Nous allons maintenant r√©gler les probl√®mes de passwords mis en clair dans un fichier de l'API.

# <InternalPageTitle> S√©curisation des passwords </InternalPageTitle>

Nous souhaitons maintenant assurer que les passwords enregistr√©s dans un support de donn√©es (un fichier ou une base de donn√©es) ne puissent pas √™tre r√©cup√©r√©s.

üëç Pour ce faire, il est recommand√© d'hacher les passwords avant de les enregistrer au niveau d'une API.

Afin de se prot√©ger contre les "hash attacks", on utilise du **salt** :
- un **salt** : c'est une donn√©e al√©atoire qui est utilis√© en entr√©e d'une fonction qui hache des donn√©es. Ainsi, si un hackeur utilise une base de donn√©es de passwords hach√©s, il devra en plus trouver le bon **salt** pour que son attaque puisse fonctionner.
- **salt round** : nombre de fois que l'op√©ration de hachage est faite, rendant les attaques de force brute plus lente et donc difficile ; une valeur de **10** semble √™tre g√©n√©ralement raisonnable et recommend√©e. 

Pour hacher sous Node.js, nous utiliserons la librairie [bcrypt](https://www.npmjs.com/package/bcrypt).

Veuillez installer la librairie **`bcrypt`** au sein de votre API **`safe`** :
```bash
npm i bcrypt
```

En r√©sum√©, nous allons utiliser :
- la fonction asynchrone **`hash`** de **`bcrypt`** pour **hacher un password** ;
- la fonction asynchrone **`compare`** de **`bcrypt`** pour **comparer un password en clair √† un password hach√©** ; si le r√©sultat est positif, cela signifie que le password fournit pour un utilisateur correspond au password initial.

Nous pr√©f√©rons utiliser les librairies asynchrone afin que l'API reste disponible √† g√©rer des requ√™tes clientes et ne bloque pas celles-ci jusqu'√† la fin d'une op√©ration de **bcrypt** !

Veuillez effacer le fichier **`/data/users.json`** contenant les credentials d'utilisateurs o√π les passwords sont donn√©s en clair.

Nous allons maintenant mettre √† jour le mod√®le de "users" pour utiliser **`bcrypt`**. Veuillez modifier **`/models/users.js`** :
```js numbered highlighting="2,9,17,21,25-26,42,46,70,73"
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const path = require('node:path');
const { parse, serialize } = require('../utils/json');

const jwtSecret = 'ilovemypizza!';
const lifetimeJwt = 24 * 60 * 60 * 1000; // in ms : 24 * 60 * 60 * 1000 = 24h

const saltRounds = 10;

const jsonDbPath = path.join(__dirname, '/../data/users.json');

const defaultUsers = [
  {
    id: 1,
    username: 'admin',
    password: bcrypt.hashSync('admin', saltRounds),
  },
];

async function login(username, password) {
  const userFound = readOneUserFromUsername(username);
  if (!userFound) return undefined;

  const passwordMatch = await bcrypt.compare(password, userFound.password);
  if (!passwordMatch) return undefined;

  const token = jwt.sign(
    { username }, // session data added to the payload (payload : part 2 of a JWT)
    jwtSecret, // secret used for the signature (signature part 3 of a JWT)
    { expiresIn: lifetimeJwt }, // lifetime of the JWT (added to the JWT payload)
  );

  const authenticatedUser = {
    username,
    token,
  };

  return authenticatedUser;
}

async function register(username, password) {
  const userFound = readOneUserFromUsername(username);
  if (userFound) return undefined;

  await createOneUser(username, password);

  const token = jwt.sign(
    { username }, // session data added to the payload (payload : part 2 of a JWT)
    jwtSecret, // secret used for the signature (signature part 3 of a JWT)
    { expiresIn: lifetimeJwt }, // lifetime of the JWT (added to the JWT payload)
  );

  const authenticatedUser = {
    username,
    token,
  };

  return authenticatedUser;
}

function readOneUserFromUsername(username) {
  const users = parse(jsonDbPath, defaultUsers);
  const indexOfUserFound = users.findIndex((user) => user.username === username);
  if (indexOfUserFound < 0) return undefined;

  return users[indexOfUserFound];
}

async function createOneUser(username, password) {
  const users = parse(jsonDbPath, defaultUsers);

  const hashedPassword = await bcrypt.hash(password, saltRounds);

  const createdUser = {
    id: getNextId(),
    username,
    password: hashedPassword,
  };

  users.push(createdUser);

  serialize(jsonDbPath, users);

  return createdUser;
}

function getNextId() {
  const users = parse(jsonDbPath, defaultUsers);
  const lastItemIndex = users?.length !== 0 ? users.length - 1 : undefined;
  if (lastItemIndex === undefined) return 1;
  const lastId = users[lastItemIndex]?.id;
  const nextId = lastId + 1;
  return nextId;
}

module.exports = {
  login,
  register,
  readOneUserFromUsername,
};
```

Voici les modifications apport√©es :
- **pour cr√©er un password hash√©** : on utilise la fonction asynchrone **`hash`** pour cr√©er le password hach√©. D√®s lors, **`createOneUser`** devient asynchrone. De plus, comme **`createOneUser`** est devenue asynchrone, dans **`register`**, pour cha√Æner le traitement de cr√©ation du token, on met un **`await`** √† l'appel de **`createOneUser`**. Et comme un **`await`** est ajout√© au sein de **`register`**, il faut mettre un **`async`** √† la m√©thode **`register`**. Attention, du coup, comme **`register`** est devenue asynchrone, il faudra aussi bien cha√Æner les traitements o√π **`register`** est appel√©, dans le router **`auths`**.
- **pour v√©rifier qu'un password en clair "match" √† un password hach√©** : on utilise la fonction asynchrone **`compare`** que l'on cha√Æne √† la cr√©ation du token √† l'aide de **`await`**. D√®s lors, la fonction **`login`** doit elle aussi √™tre d√©clar√©e **`async`**. Attention, du coup, comme `login` est devenue asynchrone, il faudra bien cha√Æner les traitements o√π **`login`** est appel√©, dans le router **`auths`**.
- **pour cr√©er l'utilisateur **`admin`** se trouvant dans les **`defaultUsers`** avec des credentials par d√©faut** : on souhaite indiquer comme **`password`** le password hach√© correspondant au password **`"admin"`**. Pour se simplifier la vie, on appelle la fonction synchrone **`hashSync`** (voir ligne 16). Bien √©videmment, dans une application plus robuste, on √©vitera d'hardcoder ce genre de secrets dans les sources de notre application üòâ !

Afin de traiter des deux fonctions du mod√®le **`users`** qui sont devenues asynchrones, **`login`** et **`register`**, nous allons modifier le router **`/routes/auths`** :
```js numbered highlighting="7,13,21,27"
const express = require('express');
const { register, login } = require('../models/users');

const router = express.Router();

/* Register a user */
router.post('/register', async (req, res) => {
  const username = req?.body?.username?.length !== 0 ? req.body.username : undefined;
  const password = req?.body?.password?.length !== 0 ? req.body.password : undefined;

  if (!username || !password) return res.sendStatus(400); // 400 Bad Request

  const authenticatedUser = await register(username, password);

  if (!authenticatedUser) return res.sendStatus(409); // 409 Conflict

  return res.json(authenticatedUser);
});

/* Login a user */
router.post('/login', async (req, res) => {
  const username = req?.body?.username?.length !== 0 ? req.body.username : undefined;
  const password = req?.body?.password?.length !== 0 ? req.body.password : undefined;

  if (!username || !password) return res.sendStatus(400); // 400 Bad Reques

  const authenticatedUser = await login(username, password);

  if (!authenticatedUser) return res.sendStatus(401); // 401 Unauthorized

  return res.json(authenticatedUser);
});

module.exports = router;
```

Nous avons simplement cha√Æn√© les r√©ponses √† faire au client seulement une fois les op√©ration `register`** et **`login`** termin√©es. Pour ce faire, nous avons pr√©c√©d√© le nom de ces m√©thodes par **`await`**. Nous avons donc du ajouter **`async`** aux fonctions middleware s'occupant des routes **`POST /auths/register`** et **`POST /auths/login`**.

Veuillez v√©rifier que votre application fonctionne correctement.  
Via l'IHM, veuillez faire un register d'un nouvel utilisateur.  
Au niveau de l'API, allez voir le contenu du nouveau fichier **`/data/users.json`**. Les passwords devraient maintenant √™tre hach√©s, comme par exemple :

```json
[
  {
    "id": 1,
    "username": "admin",
    "password": "$2b$10$RioLKlPFyYFEhv/46gR7dufDkke07eDpWH9tBt/A4Z9tJh0oJnnf2"
  },
  {
    "id": 2,
    "username": "manager",
    "password": "$2b$10$NZZ1zxOPdby6gl4Dw8K0Q.v4ZRWTbh1Ta7qcYzH5G4SrO5z71H0kO"
  }
]
```

Si tout fonctionne bien, faites un **`commit`** de votre repo (**`web2`**) avec comme message : **`api-safe tutorial`**.

En cas de souci, vous pouvez utiliser le code du tutoriel :
- pour le frontend : [jwt-fetch-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/jwt-fetch).
- pour l'API : [api-safe](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/safe).

# <InternalPageTitle> Projet 4.2 : S√©curisation d'API </InternalPageTitle>

Vous devez mettre √† jour l'API d√©velopp√©e pour [Projet 4.1](../auths-api/#project_4_1_authentification_autorisation_doperations) afin de s√©curiser l'API pour √©chapper les caract√®res dangereux. Normalement, vos passwords sont d√©j√† hach√©s car pour cr√©er le [Projet 4.1](../auths-api/#project_4_1_authentification_autorisation_doperations), vous aviez utilis√© le code offert dans le boilerplate [jwt-api-boilerplate](https://github.com/e-vinci/jwt-api-boilerplate).

Le code doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/project/4.2/api`** sur base d'un copier/coller du code de [Projet 4.1](../auths-api/#project_4_1_authentification_autorisation_doperations).

<AuthenticatedBlock>

Veuillez travailler avec les membres de votre groupe et vous partager le travail :
- certains membres peuvent travailler sur cette s√©curisation ;
- d'autres membres sur d'autres aspect du projet.

Un peu avant la fin de la s√©ance, veuillez discuter :
- pr√©senter ce que vous avez appris au niveau de la s√©curisation aux membres qui ont travaill√© sur autre chose.

</AuthenticatedBlock>

Vous devez tester, √† l'aide de Rest Client, toutes les op√©rations que vous avez modifi√©es.

Quand un prototype d'api est finalis√© et test√©, veuillez faire un **`commit`** de votre code avec comme message : **`4.2 : api bcrypt & escape-html`**.

#### ü§ù Tips

‚ö° N'oubliez pas que vos m√©thodes de **`login`** et de **`register`** deviennent asynchrones, cela impose de bien cha√Æner les traitements dans le router, sinon vous risquez de renvoyer des objets vides en r√©ponses aux requ√™tes.

# <InternalPageTitle> üç¨ Authentification & autorisation JWT √† l'aide de cookies </InternalPageTitle>

## Pourquoi utiliser l'autorisation JWT √† l'aide de cookies ?

Dans la partie sur l'[Authentification et autorisation d'acc√®s aux op√©rations d'une RESTful API via JWT](../auths-api/), nous avons vu une fa√ßon de g√©rer des token JWT, sans g√©rer de cookies.

Cela impose aux client de sauvegarder les token et de les envoyer dans un **`authorization header`** lorsqu'ils souhaitent acc√©der √† une op√©ration prot√©g√©e.

Il est aussi possible d'int√©grer les tokens au sein de cookies. Dans ce cas-l√†, les clients qui ont re√ßu un cookie de l'API renverront automatiquement ce cookie (m√©canisme des browsers). Les tokens JWT voyageront automatiquement gr√¢ce au m√©canisme de cookies.

üí≠ Faut-il mieux int√©grer les token JWT dans des cookies ou pas ?  
Il est difficile de donner une r√©ponse √† cette question. Chaque approche a des avantages et des inconv√©nients. Ce qui devrait √™tre le point d'attention, c'est la s√©curit√©. Et dans les deux cas, on atteint un niveau de s√©curit√© raisonnable.
Pour ce cours, nous avons choisi la fa√ßon la plus moderne, en laissant au client le choix de sauvegarder les token dans le web storage (nous allons voir √ßa tout prochainement pour l'aspect frontend).  
Notons que le cas le plus s√ªr est probablement d'avoir deux types de token, ce qui est d'une complexit√© qui d√©passe les objectifs de ce cours. N√©anmoins, pour votre info, les m√©canismes d'authentification comme OAuth (authorization de MS Azure) & OpenID Connect (authentification de MS Azure) g√®re deux types de token :
- un token √† dur√©e de vie courte qui sera enregistr√© en m√©moire vive au niveau du client (access token) ou dans le localStorage.
- un token √† dur√©e de vie longue qui sera enregistr√© par le client dans un cookie (refresh token, notamment utilis√© par l'API pour cr√©er un nouvel access token).

## Un cookie, c'est quoi ?

Un **cookie** repr√©sente des donn√©es qu'un serveur envoie √† un browser.  
Le browser peut sauver ce cookie. Pour chaque requ√™te faite au serveur sur la m√™me origine (que l'origine o√π le cookie a √©t√© re√ßu), le cookie sera automatiquement envoy√© au serveur.

Il fut un temps o√π les cookies √©taient utilis√©s comme un m√©canisme g√©n√©ral de stockage de donn√©es c√¥t√© client. 

üëç Actuellement, si les cookies sont utilis√©s pour sauvegarder les donn√©es de session, il faut se prot√©ger contre les attaques XSS et rendre les cookies inaccessibles au JavaScript : on utilise donc les cookies **`HttpOnly`** qui sont inaccessibles √† la **`Document.cookie API`**. 

Pour la suite, on va donc voir :
- comment utiliser Express pour cr√©er des cookies au niveau d'une API ;
- comment rendre ces cookies inaccessibles aux attaques XSS en configurant **`HttpOnly`**.

## Impl√©mentation de l'authentification & l'autorisation JWT au sein de cookies

### Intro

Nous allons donc cr√©er une nouvelle version de l'API sauvegardant le token d'un utilisateur au sein d'un cookie, ainsi que son username, sans que ces infos soient accessible au JS c√¥t√© client.

Pour ce faire nous allons utiliser la librairie [cookie-session](https://github.com/expressjs/cookie-session) qui permet d'enregistrer des donn√©es de session dans des cookies.

Nous allons maintenant continuer le d√©veloppement de l'API [safe](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/safe).

Au sein de votre repo **`web2`**, veuillez cr√©er le projet nomm√© **`/web2/tutorials/pizzeria/api/cookies`** sur base d'un copi√©/coll√© de **`/web2/tutorials/pizzeria/api/safe`** (ou [api-safe](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/safe)).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**`/web2/tutorials/pizzeria/api/cookies`**.

Veuillez installer la librairie **`cookie-session`** au sein de votre nouveau projet **`cookies`** :
```bash
npm i cookie-session
```

### Utilisation de la fonction middleware **cookieSession**

Veuillez mettre √† jour **`/app.json`** pour mettre en place la gestion de cookies :

```js highlighting="4,12-21"
const express = require('express');
const cookieParser = require('cookie-parser');
const logger = require('morgan');
const cookieSession = require('cookie-session');

const usersRouter = require('./routes/users');
const pizzaRouter = require('./routes/pizzas');
const authsRouter = require('./routes/auths');

const app = express();

const expiryDateIn3Months = new Date(Date.now() + 1000 * 60 * 60 * 24 * 30 * 3);
const cookieSecreteKey = 'YouWouldnot!not!like!mypizza';
app.use(
  cookieSession({
    name: 'user',
    keys: [cookieSecreteKey],  
    httpOnly: true,
    expires: expiryDateIn3Months,
  }),
);

app.use(logger('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());

app.use('/users', usersRouter);
app.use('/pizzas', pizzaRouter);
app.use('/auths', authsRouter);

module.exports = app;
```

Nous avons donc bien indiqu√© que le cookie est inaccessible au JS via : **`httpOnly: true`**.

Nous avons fait en sorte que le cookie soit sign√© via la cl√© **`cookieSecreteKey`**.  
Le m√©canisme de signature correspond √† ce qui a √©t√© vu dans le cadre des tokens JWT.  
Ainsi, si un cookie venait √™tre modifi√© par un utilisateur, lors de la v√©rification du cookie, cela sera automatiquement d√©tect√© par la fonction middleware **`cookieSession`** et la session ne sera pas cr√©√©e.

Pour info, la fonction middleware **`cookieSession`** va cr√©er deux cookies :
- un cookie portant comme nom la valeur de **`name`** ; il est encod√© en base64. N'h√©sitez pas √† vous amuser √† d√©coder un cookie g√©n√©r√© par **`cookieSession`** sur [base64decode](https://www.base64decode.org/).
- un cookie portant comme nom la valeur de **`name`** + **`.sig`** : c'est la signature qui pr√©vient contre le "tempering" (acte intentionnel mais non autoris√© qui am√®ne √† la modification d'un syst√®me ou de donn√©es).

### Lecture et ajout de donn√©es de session via `req.session`

Pour cr√©er des donn√©es de session, il suffit de simplement les ajouter √† l'objet **`req.session`**.

Dans le cadre de la RESTful API g√©rant les pizzas, cela est fait lors d'une op√©ration de type **`register`** ou **`login`**.

Veuillez mettre √† jour le router **`/routes/auths.js`** :

```js numbered highlighting="17,19,33,35,38-42,44-47"
const express = require('express');
const { register, login } = require('../models/users');

const router = express.Router();

/* Register a user */
router.post('/register', async (req, res) => {
  const username = req?.body?.username?.length !== 0 ? req.body.username : undefined;
  const password = req?.body?.password?.length !== 0 ? req.body.password : undefined;

  if (!username || !password) return res.sendStatus(400); // 400 Bad Request

  const authenticatedUser = await register(username, password);

  if (!authenticatedUser) return res.sendStatus(409); // 409 Conflict

  createCookieSessionData(req, authenticatedUser);

  return res.json({ username: authenticatedUser.username });
});

/* Login a user */
router.post('/login', async (req, res) => {
  const username = req?.body?.username?.length !== 0 ? req.body.username : undefined;
  const password = req?.body?.password?.length !== 0 ? req.body.password : undefined;

  if (!username || !password) return res.sendStatus(400); // 400 Bad Reques

  const authenticatedUser = await login(username, password);

  if (!authenticatedUser) return res.sendStatus(401); // 401 Unauthorized

  createCookieSessionData(req, authenticatedUser);

  return res.json({ username: authenticatedUser.username });
});

/* Logout a user */
router.get('/logout', (req, res) => {
  req.session = null;
  return res.sendStatus();
});

function createCookieSessionData(req, authenticatedUser) {
  req.session.username = authenticatedUser.username;
  req.session.token = authenticatedUser.token;
}

module.exports = router;
```

Dans le code ci-dessus, nous pr√©parons les donn√©es de session qui seront √©crites dans le cookie √† l'aide de l'objet **`req.session`**.  
Lorsque nous renvoyons du JSON aux clients, nous ne renvoyons plus le token, mais juste le username de l'utilisateur. L'application cliente, le browser, pourra utiliser cette info pour afficher le nom de l'utilisateur. Pour rappel, le browser n'a pas acc√®s, via le JS, √† l'info se trouvant dans le cookie.

Quand nous g√©rons une session via des cookies, il n'est pas √©vident de bien cl√¥re une session. Nous avons cr√©√© une nouvelle op√©ration de type **`GET /auths/logout`** qui permet d'effacer les donn√©es de session d'un utilisateur.

Il nous reste √† changer le m√©canisme d'autorisation.
Les tokens ne seront plus re√ßu via un authorization header, mais via un cookie.  
Nous allons donc mettre √† jour le middleware **`/utils/authorize`** (1 seule ligne) :

```js numbered highlighting="7"
const jwt = require('jsonwebtoken');
const { readOneUserFromUsername } = require('../models/users');

const jwtSecret = 'ilovemypizza!';

const authorize = (req, res, next) => {
  const { token } = req.session;
  if (!token) return res.sendStatus(401);

  try {
    const decoded = jwt.verify(token, jwtSecret);
    console.log('decoded', decoded);
    const { username } = decoded;

    const existingUser = readOneUserFromUsername(username);

    if (!existingUser) return res.sendStatus(401);

    req.user = existingUser; // request.user object is available in all other middleware functions
    return next();
  } catch (err) {
    console.error('authorize: ', err);
    return res.sendStatus(401);
  }
};

const isAdmin = (req, res, next) => {
  const { username } = req.user;

  if (username !== 'admin') return res.sendStatus(403);
  return next();
};

module.exports = { authorize, isAdmin };
```

# <InternalPageTitle> üç¨ Test via REST Client d'une RESTful API attendant des cookies </InternalPageTitle>

Il nous reste √† tester nos requ√™tes via REST Client.

Il n'y a pas de nouvelles notions √† apprendre pour utiliser REST Client avec des cookies : le comportement par d√©faut de REST Client, lorsqu'un cookie est renvoy√© dans une r√©ponse, est d'inclure ce cookie dans chaque requ√™te vers la m√™me origine.

D√®s lors, pour tester l'API, il suffit d'enlever tous les authorization headers et de rajouter une requ√™te pour tester l'effacement d'une session.

Veuillez tester les requ√™tes √† l'aide de **`/REST Client/pizzas.http`** :

```http
######### NORMAL OPERATION  ###########

### Read all pizzas
GET http://localhost:3000/pizzas

### Read all pizzas with File variable
@baseUrl = http://localhost:3000
GET {{baseUrl}}/pizzas

### Read all pizzas sorted by title (ascending)
GET {{baseUrl}}/pizzas/?order=+title

### Read all pizzas sorted by title (descending)
GET {{baseUrl}}/pizzas/?order=-title

### Read pizza identified by 2
GET {{baseUrl}}/pizzas/2

### Create a pizza by using the admin account
#### First login as the admin
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"admin",
    "password":"admin"
}

#### Create a pizza with the admin token
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### Delete pizza identified by 2 with the admin token
DELETE {{baseUrl}}/pizzas/2

### Update the pizza identified by 6 with the admin token
PATCH {{baseUrl}}/pizzas/6
Content-Type: application/json

{
    "title":"Magic Green 2"
}


######### ERROR OPERATION  ###########

### 1. Create a pizza without a token
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### 2. Create a pizza without being the admin, use manager account
#### 2.1 First login as the manager
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"manager",
    "password":"manager"
}

#### 2.2 Try to create a pizza with the manager token
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### Read pizza which does not exists
GET {{baseUrl}}/pizzas/100

### Create a pizza which lacks a property
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### Create a pizza without info for a property
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### Update for a pizza which does not exist
PATCH {{baseUrl}}/pizzas/200
Content-Type: application/json

{
    "title":"Magic Green 2"
}

### Update for a pizza which does not provide any info for a property
PATCH {{baseUrl}}/pizzas/1

Content-Type: application/json

{
    "title":"Magic Green 2",
    "content":""
}
```

**`/REST Client/auths.http`** a √©t√© mis √† jour pour tester **`GET /auths/logout`** :
```http
### Logout any user
GET {{baseUrl}}/auths/logout
```

Pour ajouter une pizza, il suffit juste :
1. De loguer l'admin.
2. De cr√©er une nouvelle pizza ; le cookie est automatiquement envoy√©.

Admettons que vous souhaitez tester l'ajout d'une pizza sans envoyer de token :
1. Lancez l'op√©ration de logout (**`GET /auths/logout`**) ; le cookie renvoy√© ne contient pas de donn√©es de session ;
2. Tentez la cr√©ation d'une pizza qui renverra un code **`401 Unauthorized`**.

Si tout fonctionne bien, faites un **`commit`** de votre repo (**`web2`**) avec comme message :
**`api-cookies tutorial`**.

En cas de souci, vous pouvez utiliser le code du tutoriel [api-cookies](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/cookies).