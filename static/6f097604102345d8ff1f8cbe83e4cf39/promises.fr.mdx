---
title: "Promesses"
description: "Programmation asynchrone & les promesses"
---

# l) Programmation asynchrone & les promesses

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part2"> Partie 2 </PathViewerItem>
    <PathViewerItem selected> l) Programmation asynchrone & les promesses </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Utilisation de promesses & async / await </InternalPageMenuItem> 
  <InternalPageMenuItem> Op√©ration asynchrone d'√©criture d'une ressource </InternalPageMenuItem> 
  <InternalPageMenuItem> Cr√©ation de fonctions asynchrones renvoyant une promesse </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 2.19 : Int√©gration de la RESTful API au sein de l'IHM de myMovies via un proxy </InternalPageMenuItem>
</InternalPageMenu>

<div className="card card__simple-youtube-container">
    <YoutubeImage src="https://youtu.be/6xe9rpUPCvQ" />
</div>

# <InternalPageTitle> Utilisation de promesses & async / await </InternalPageTitle>

## Introduction

Plut√¥t que d'utiliser des **`.then()`** pour cha√Æner des traitements asynchrones, il est possible de simplifier la syntaxe des promesses √† l'aide de **`async`** et **`await`**.

On va donc √©crire du code d'une mani√®re √©quivalente √† ce qui serait fait en programmation synchrone, tout en b√©n√©ficiant des effets de la programmation asynchrone.

## async / await : les bases

Pour ce nouveau tutoriel, nous allons refactorer l'IHM pour am√©liorer le code associ√© aux appels asynchrones aux API.

Au sein de votre repo **`web2`**, veuillez cr√©er le projet nomm√© **`/web2/tutorials/pizzeria/hmi/async-await`** sur base d'un copi√©/coll√© de **`/web2/tutorials/pizzeria/hmi/basic-fetch`** (ou [basic-fetch-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/basic-fetch)).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**`/web2/tutorials/pizzeria/hmi/async-await`**.

Nous allons donc refactorer le code o√π est fait le **`fetch`**, c'est √† dire **`/src/Components/Pages/HomePage.js`** (veuillez mettre √† jour tout le code de la fonction **`arrow`** associ√©e √† la variable **`HomePage`**) :

```js numbered highlighting="1-2,5,9,14-16"
const HomePage = async () => {
  try {
    clearPage();

    const response = await fetch('/api/pizzas');

    if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);

    const pizzas = await response.json();

    renderMenuFromString(pizzas);
    attachOnMouseEventsToGoGreen();
    renderDrinksFromNodes(DRINKS);
  } catch (err) {
    console.error('HomePage::error: ', err);
  }
};
```

Pour tester ce code, il ne faut pas oublier de d√©marrer la RESTful API auparavant : **`/web2/tutorials/pizzeria/api/fat-model`** ou via le code de ce web repo si vous avez un souci : [api-fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model).

Voici quelques caract√©ristiques importantes de **`async`** / **`await`** :

- **`await`** est utilis√© pour cha√Æner une t√¢che asynchrone (sur une fonction renvoyant une promesse) et ne peut se faire qu'au sein d'une fonction tagu√©e par **`async`** ; c'est donc le rempla√ßant du **`.then(callback)`**.  
  ‚ö° Attention, il est donc important qu'au niveau de la fonction **`arrow`**, √† la ligne 1 du code donn√© ci-dessus, on indique le **`async`** !  
  ‚ö° Dans le code donn√© ci-dessus, il est aussi tr√®s important de ne pas oublier les **`await`**. N'h√©sitez pas √† faire le test en enlevant le **`await`** de **`const pizzas = await response.json();`**.  
  Que se passe-t-il dans ce cas ? **`response.json()`** √©tant une fonction asynchrone, on passera directement √† la fonction **`renderMenuFromString(pizzas);`** avant m√™me d'avoir r√©cup√©r√© les pizzas de notre RESTful API !
- Toute fonction "tagu√©e" par **`async`** renvoie automatiquement une promesse ; cela signifie dans le code ci-dessus que la fonction **`HomePage`** est elle m√™me asynchrone.  
üí≠ Il est √† parier, et n'h√©sitez pas √† trouver un moyen de vous en rendre compte visuellement, que le footer s'affiche avant le menu !
- On utilise des blocs **`try`** / **`catch`** pour g√©rer les erreur ; c'est donc le rempla√ßant du **`.catch(callback)`**.

# <InternalPageTitle> Op√©ration asynchrone d'√©criture d'une ressource </InternalPageTitle>

A pr√©sent, nous souhaiterions que notre IHM puisse cr√©er une ressource au sein de la RESTful API. Dans un premier temps, nous allons mettre √† jour le frontend en acceptant que n'importe quel utilisateur puisse cr√©er une pizza et l'ajouter au menu de la pizzeria.  
Bien entendu, cela est temporaire. Nous verrons plus tard comment s√©curiser cette op√©ration, en autorisant un admin seulement √† r√©aliser l'ajout d'une pizza au menu.

Nous allons cr√©er une nouvelle page nomm√©e **`AddPizzaPage.js`**.
Pour commencer, nous allons r√©aliser une page statique car il est toujours plus ais√© de d'abord avoir une version visuelle d'une application web, avec la navigation entre les pages, avant de peaufiner chaque page et leurs interactions avec les utilisateurs et les APIS.
Veuillez ajouter ce code dans la nouvelle page **`/src/Components/Pages/AddPizzaPage.js`**:

```js
import { clearPage, renderPageTitle } from '../../utils/render';

const AddPizzaPage = () => {
  clearPage();
  renderPageTitle('Add a pizza to the menu');
  renderAddPizzaForm();
};

function renderAddPizzaForm() {
  const main = document.querySelector('main');
  const form = document.createElement('form');
  form.className = 'p-5';
  const title = document.createElement('input');
  title.type = 'text';
  title.id = 'title';
  title.placeholder = 'title of your pizza';
  title.required = true;
  title.className = 'form-control mb-3';
  const content = document.createElement('input');
  content.type = 'text';
  content.id = 'content';
  content.required = true;
  content.placeholder = 'Content of your pizza';
  content.className = 'form-control mb-3';
  const submit = document.createElement('input');
  submit.value = 'Add pizza to the menu';
  submit.type = 'submit';
  submit.className = 'btn btn-danger';
  form.appendChild(title);
  form.appendChild(content);
  form.appendChild(submit);
  main.appendChild(form);
}

export default AddPizzaPage;
```

Nous devons aussi ajouter un √©l√©ment dans la **`Navbar`** afin de pouvoir acc√©der √† cette nouvelle page. Pour ce faire, veuillez mettre √† jour **`/src/Components/Navbar/Navbar.js`** :

```js numbered highlighting="36-38"
// eslint-disable-next-line no-unused-vars
import { Navbar as BootstrapNavbar } from 'bootstrap';

const Navbar = () => {
  renderNavbar();
};

function renderNavbar() {
  const navbar = document.querySelector('#navbarWrapper');
  navbar.innerHTML = `
  <nav class="navbar navbar-expand-lg navbar-light bg-danger">
        <div class="container-fluid">
          <a class="navbar-brand" href="#">e-Pizzeria</a>
          <button
            class="navbar-toggler"
            type="button"
            data-bs-toggle="collapse"
            data-bs-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent"
            aria-expanded="false"
            aria-label="Toggle navigation"
          >
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
              <li class="nav-item">
                <a class="nav-link active" aria-current="page" href="#" data-uri="/">Home</a>
              </li>
              <li id="loginItem" class="nav-item">
                <a class="nav-link" href="#" data-uri="/login">Login</a>
              </li>
              <li id="registerItem" class="nav-item">
                <a class="nav-link" href="#" data-uri="/register">Register</a>
              </li>  
              <li class="nav-item">
                <a class="nav-link" href="#" data-uri="/add-pizza">Add a pizza</a>
              </li>           
            </ul>
          </div>
        </div>
      </nav>
  `;
}

export default Navbar;
```

Et finalement, comme le frontend de ce tutoriel utilise le boilerplate du cours, il faut encore configurer le router de l'IHM afin d'indiquer la page √† afficher lorsqu'on clique sur le lien dont **`data-uri`** vaut **`"/add-pizza"`**. Pour ce faire, veuillez mettre √† jour le fichier **`/src/Components/Router/Router.js`** pour ajouter ces deux lignes :

```js highlighting="1,10"
import AddPizzaPage from '../Pages/AddPizzaPage';
import HomePage from '../Pages/HomePage';
import LoginPage from '../Pages/LoginPage';
import RegisterPage from '../Pages/RegisterPage';

const routes = {
  '/': HomePage,
  '/login': LoginPage,
  '/register': RegisterPage,
  '/add-pizza': AddPizzaPage,
};
```

A ce stade-ci, votre application **`/web2/tutorials/pizzeria/hmi/async-await`** devrait √™tre fonctionnelle, vous devriez pouvoir naviguer vers la nouvelle page contenant un formulaire pour ajouter une pizza.

Nous allons maintenant ajouter l'interaction avec l'API au sein de **`AddPizzaPage`**.
Lorsque nous soumettons le formulaire, nous voulons faire une requ√™te de cr√©ation de pizza √† la RESTful API, c'est donc une requ√™te de type **`POST /pizzas`** qui doit √™tre l'√©quivalent de ce que nous faisions avec REST Client. Pour rappel, nous faisions une requ√™te de ce genre :

```http
### Create a pizza
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Ici, c'est le JS √† rajouter dans **`AddPizzaPage`** qui doit, lors du clic, aller chercher les valeurs des deux champs du formulaire pour cr√©er la repr√©sentation des donn√©es (**`title`** et **`content`**) et faire un **`fetch`** de l'op√©ration de cr√©ation offerte par l'API.  
Si l'ajout se fait avec succ√®s, on souhaite faire en sorte que l'utilisateur soit redirig√© vers la **`HomePage`**.

Pour arriver √† nos fins, veuillez ajouter ce code dans la page **`/src/Components/Pages/AddPizzaPage.js`** :

```js numbered highlighting="34,37-63"
import { clearPage, renderPageTitle } from '../../utils/render';
import Navigate from '../Router/Navigate';

const AddPizzaPage = () => {
  clearPage();
  renderPageTitle('Add a pizza to the menu');
  renderAddPizzaForm();
};

function renderAddPizzaForm() {
  const main = document.querySelector('main');
  const form = document.createElement('form');
  form.className = 'p-5';
  const title = document.createElement('input');
  title.type = 'text';
  title.id = 'title';
  title.placeholder = 'title of your pizza';
  title.required = true;
  title.className = 'form-control mb-3';
  const content = document.createElement('input');
  content.type = 'text';
  content.id = 'content';
  content.required = true;
  content.placeholder = 'Content of your pizza';
  content.className = 'form-control mb-3';
  const submit = document.createElement('input');
  submit.value = 'Add pizza to the menu';
  submit.type = 'submit';
  submit.className = 'btn btn-danger';
  form.appendChild(title);
  form.appendChild(content);
  form.appendChild(submit);
  main.appendChild(form);
  form.addEventListener('submit', onAddPizza);
}

async function onAddPizza(e) {
  e.preventDefault();

  const title = document.querySelector('#title').value;
  const content = document.querySelector('#content').value;

  const options = {
    method: 'POST',
    body: JSON.stringify({
      title,
      content,
    }),
    headers: {
      'Content-Type': 'application/json',
    },
  };

  const response = await fetch('/api/pizzas', options); // fetch return a promise => we wait for the response

  if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);

  const newPizza = await response.json(); // json() returns a promise => we wait for the data

  console.log('New pizza added : ', newPizza);

  Navigate('/');
}

export default AddPizzaPage;
```

Quelques explications sur ce code, pour les parties d√©j√† connues :

- La gestion d'√©v√©nements n'est pas nouvelle. Ici, on met un √©couteur d'√©v√©nements de type **`submit`** sur le formulaire. Cela permet d'√©couter tant les clics sur le champs de type **`submit`** (le bouton) que si l'utilisateur appuie sur **`Enter`**.  
üëç On recommande, pour les formulaires, d'utiliser des √©v√©nements de type **`submit`** plut√¥t que des √©v√©nements de type **`click`** sur le bouton **`submit`** afin notamment de prendre en compte si l'utilisateur appuie sur **`Enter`** pour tenter de soumettre le formulaire.
- L'action par d√©faut d'un formulaire, lors d'un submit, et de faire une requ√™te synchrone vers l'URL du backend indiqu√© dans la propri√©t√© **`action`** du formulaire, ou sur la m√™me URL que la page en cours si **`action`** n'est pas donn√©. Pour √©viter un chargement de page non d√©sir√© dans le cadre d'une SPA, on stoppe cette action par d√©faut via **`e.preventDefault()`**.

Pour la nouveaut√© et le **`fetch`** :
- pour faire une requ√™te de type **`POST`**, tout comme pour les requ√™tes de type **`DELETE`**, **`PATCH`**, **`UPDATE`**..., il faut l'indiquer √† la m√©thode **`fetch`**.  
Cela est indiqu√© dans un objet que nous appelons g√©n√©ralement **`options`** qui doit contenir la propri√©t√© **`method`**.
- lorsque l'on doit envoyer des donn√©es dans le **`body`** d'une requ√™te, alors il faut le faire au sein de la propri√©t√© **`body`**. Ici, nous souhaitons envoyer un objet contenant les propri√©t√©s **`title`** et **`content`** au format JSON. Nous devons donc utiliser la m√©thode **`JSON.stringify`** qui permet de cr√©er une repr√©sentation JSON d'un objet JS. Notez ici que nous avons √©crit l'objet JS selon une notation simplifi√©e ("object property shorthand") :

```js highlighting="4-7,9-12"
const title = document.querySelector('#title').value;
const content = document.querySelector('#content').value;

{
  title,
  content,
}
// Cet object literal est l'√©quivalent de :
{
  title: title,
  content: content,
}
```

- Il est tr√®s important de sp√©cifier le type de la repr√©sentation de l'objet qui devrait √™tre utilis√© par l'API et qui se trouve dans le body de la requ√™te. Cela est fait via un **`header`** et la propri√©t√© **`Content-Type`** (**`'Content-Type': 'application/json',`**).  
‚ö° Si vous oubliez cela, l'API ne pourra pas parser les donn√©es au format JSON vers des objets JS et donc les op√©rations d'√©criture de ressources √©choueront !
- Finalement, si l'op√©ration de cr√©ation de la pizza r√©ussi, nous redirigeons l'utilisateur vers la **`HomePage`** √† l'aide du composant fonctionnel **`Navigate`** offert au sein du module **`Navigate.js`** dans le dossier **Router** du boilerplate du frontend.

Si tout fonctionne bien, faites un **`commit`** de votre repo (**`web2`**) avec comme message
: **`async-await-hmi tutorial`**.

En cas de souci, vous pouvez acc√©der au code du tutoriel ici :
[async-await-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/async-await).

# <InternalPageTitle> Cr√©ation de fonctions asynchrones renvoyant une promesse </InternalPageTitle>

A l'aide d'**`async`** / **`await`**, il est tr√®s simple de cr√©er des fonctions asynchrones qui renvoient une promesse.

Imaginons que nous souhaitons cr√©er une fonction asynchrone qui renvoie toutes les pizzas qui sont offertes par l'op√©ration de lecture des pizzas de la RESTful API.

Voici comment nous √©cririons ce code :

```js
async function getAllPizzas() {
  try {
    const response = await fetch('/api/pizzas');

    if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);

    const pizzas = await response.json();

    return pizzas;
  } catch (err) {
    console.error('getAllPizzas::error: ', err);
    throw err;
  }
}
```

Cette fonction **`getAllPizzas`** ne renvoie pas un array de pizzas, mais une **`Promise`** !  
Si la promesse :
- r√©sout avec succ√®s, alors c'est bien un array de pizzas qui sera renvoy√© par cette fonction.
- √©choue, c'est une exception qui sera renvoy√©e.  
Pour que cela fonctionne, vous devez donc faire en sorte, dans vos fonctions asynchrones, de faire un **`throw`** d'une erreur en cas d'√©chec du traitement asynchrone.

Comment utiliser ce code au sein de la **`HomePage`** ?  
Voici comment le code pourrait √™tre mis √† jour pour utiliser la fonction asynchrone **`getAllPizzas`** au sein de **`HomePage.js`** :

```js highlighting="1,5"
const HomePage = async () => {
  try {
    clearPage();

    const pizzas = await getAllPizzas();

    renderMenuFromString(pizzas);
    attachOnMouseEventsToGoGreen();
    renderDrinksFromNodes(DRINKS);
  } catch (err) {
    console.error('HomePage::error: ', err);
  }
};
```

# <InternalPageTitle> Exercice 2.19 : Int√©gration de la RESTful API au sein de l'IHM de myMovies via un proxy </InternalPageTitle>

## Objectif

Vous allez int√©grer le frontend de **myMovies** avec sa RESTful API afin que toutes les op√©rations CRUD soient trait√©es par votre application.

L'application **myMovies** doit permettre tous ces cas d'utilisation (ou use cases):
-	UC1 : l'affichage, sous forme de tableau, de toutes les ressources de type films.
-	UC2 : l'ajout d'une ressource de type films via un formulaire d'ajout d'un film.
- UC3 : la suppression d'un film.
- UC4 : la mise √† jour des donn√©es d'un film (√† l'exception de l'id associ√© √† un film).

Nous acceptons, √† ce stade-ci, que des utilisateurs anonymes puissent r√©aliser des op√©rations qui normalement devraient √™tre s√©curis√©es. Nous verrons plus tard comment authentifier et autoriser des utilisateurs afin de prot√©ger l'acc√®s aux op√©rations d'API.

Veuillez utiliser le proxy de votre frontend afin de contourner les probl√®mes associ√© √† la gestion des CORS. Tous les appels aux op√©rations des API doivent se faire √† l'aide de **`async`** / **`await`**. 

## Mise en place des projets

<UnAuthenticatedBlock>

Vous allez donc d√©velopper deux applications :
- Pour votre frontend : 
  - Si vous avez choisi comme projet de continuer l'application **myMovies** : veuillez repartir du code de [Projet 2.17](../comms-security/#projet_2_17_consommation_doperations_dune_api_a_laide_dun_proxy). 
  - Si vous avez choisi votre propre projet : veuillez repartir du code de l'[Exercice 2.11](../routing/#exercice_2_11_utilisation_dun_router). 
  - Dans les deux cas : le code du frontend doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/project/2.19/frontend`**.
- Pour votre API : Veuillez repartir du code de l'[Exercice 1.9](../../part1/refactoring/#exercice_1_9_refactoring_a_laide_dun_fat_model). le code doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/project/2.19/api`**.

</UnAuthenticatedBlock>

<AuthenticatedBlock>

Vous allez donc d√©velopper deux applications :
- Pour votre frontend : veuillez repartir du code de l'[Exercice 2.11](../routing/#exercice_2_11_utilisation_dun_router). Le code du frontend doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/project/2.19/frontend`**.
- Pour votre API : Veuillez repartir du code de l'[Exercice 1.10](../../part1/refactoring/#exercice_1_10_encore_un_fat_model). le code doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/project/2.18/api`**.

</AuthenticatedBlock>

Vous allez d√©velopper le frontend de mani√®re incr√©mentale.

## UC1 : l'affichage, sous forme de tableau, de toutes les ressources de type films

Veuillez consommer l'op√©ration de lecture de films de l'API au sein de **`ViewMoviePage`** √† l'aide de **`async`** / **`await`** et du proxy.

Quand c'est fonctionnel, veuillez faire un **`commit`** de votre code avec comme message : **`2.19.1 : spa read operation & async / await`**.

## UC2 : l'ajout d'une ressource de type films via un formulaire d'ajout d'un film

Veuillez consommer l'op√©ration de cr√©ation de films de l'API au sein de **`AddMoviePage`** √† l'aide de **`async`** / **`await`** et du proxy.

‚ö° Lors de l'ajout d'un film, n'oubliez pas que le budget et la dur√©e doivent √™tre des nombres, pas des strings !

Quand c'est fonctionnel, veuillez faire un **`commit`** de votre code avec comme message : **`2.19.2 : spa create operation`**.

## UC3 : la suppression d'un film

Veuillez consommer l'op√©ration de suppression de films de l'API au sein de **`ViewMoviePage`** √† l'aide de **`async`** / **`await`** et du proxy.

Quand c'est fonctionnel, veuillez faire un **`commit`** de votre code avec comme message : **`2.19.3 : spa delete operation`**.

## UC4 : la mise √† jour des donn√©es d'un film (√† l'exception de l'id associ√© √† un film)

Veuillez consommer l'op√©ration de mise √† jour de films de l'API au sein de **`ViewMoviePage`** √† l'aide de **`async`** / **`await`** et du proxy.

Quand c'est fonctionnel, veuillez faire un **`commit`** de votre code avec comme message : **`2.19.4 : spa update operation`**.

#### ü§ù Tips

Comment g√©rer l'UC de suppression d'un film ?
- Vous pourriez avoir un bouton **`Delete`** pour chaque ligne du tableau affichant les films. Lors du clic sur un bouton **`Delete`**, vous feriez une requ√™te de type **`DELETE`** vers la RESTful API. Attention, pour une requ√™te de type **`DELETE`**, l'identifiant de l'objet √† supprimer doit √™tre donn√©e dans l'URL associ√©e au **`fetch`**.
- Comment retrouver l'identifiant du film affich√© dans le tableau ?   
Pensez au **`data-attribute`**, vous pouvez cacher de l'information dans l'HTML. Par exemple, chaque bouton **`Delete`** pourrait contenir un **`data-attribute`** √©tant l'id du film. Il est aussi possible d'utiliser la propri√©t√© **`id`** du bouton pour "cacher" de l'info.

Comment g√©rer la mise √† jour des donn√©es d'un film ? Nous vous proposons deux options √† choix :
- L'option 1 : elle va vous permettre de ne pas devoir cr√©er des formulaires et de directement mettre √† jour de l'info en modifiant le contenu de containers HTML.
- L'option 2 : vous pourriez cr√©er des formulaires en les pr√©-remplissant des donn√©es existantes.

### Option 1 pour la mise √† jour d'info : la plus cool √† d√©couvrir üòâ

Vous pourriez faire en sorte que l'HTML du tableau affichant les films, lors d'un clic, devienne √©ditable. Pour cette option :
- Voici, √† quoi pourrait ressembler votre application √† la fin de l'exercice. Vous avez bien s√ªr la libert√© de faire quelque chose de totalement diff√©rent visuellement !  
<ScrollableImage name="movies.png" minWidth="700px" maxWidth="1268px" />
- Veuillez noter que, contrairement √† ce qui a √©t√© fait pour l'[Exercice 2.11](../routing/#exercice_2_11_utilisation_dun_router), le **`title`** et le **`link`** ne sont plus int√©gr√©s dans une m√™me colonne, via des hyperlinks ; avec l'option 1, nous devrions consid√©rer deux colonnes, une pour le titre et l'autre pour le lien.
- Vous pouvez utiliser la propri√©t√© HTML **`contenteditable="true"`** pour rendre les cellules du tableau √©ditables. Voici un exemple pour rendre une cellule associ√©e au titre √©ditable :
  ```js highlighting="1"
  <td class="fw-bold text-info" contenteditable="true">${
              element.title
  }</td>
  ``` 
- Pour acc√©der aux cellules qui se trouvent dans une m√™me ligne que vous mettez √† jour, vous pouvez utiliser la DOM API de votre browser :
  - on obtient le parent d'un √©l√©ment HTML via l'attribut **`parentElement`** ; par exemple, si vous avez un √©couteur d'√©v√©nements de clics sur un bouton **`Save`**, ce bouton se trouvant au sein d'une **`td`** qui se trouve elle-m√™me au sein d'une **`tr`** : **`e.target.parentElement.parentElement`**  donne acc√®s √† la **`tr`** associ√©e au bouton **`Save`** sur lequel on a cliqu√©.
  - on acc√®de aux enfants d'un √©l√©ment HTML via l'attribut **`children`** ; par exemple, **`tr.children[0]`** donne acc√®s √† la premi√®re **`td`** au sein de **`tr`**.
- Vous pourriez avoir un bouton **`Save`** pour chaque ligne du tableau affichant un film. Lors d'un clic sur un bouton **`Save`**, vous faites appel √† l'API en faisant la requ√™te de mettre √† jour toutes les propri√©t√©s du film, m√™me celle n'ayant pas de nouvelles valeurs.
- Attention, pour une requ√™te de type **`PUT`** (mise √† jour de toutes les propri√©t√©s d'une ressource) ou de type **`PATCH`** (mise √† jour partielle d'une ressource), vous devez indiquer l'id dans l'URL du **`fetch`**, et la repr√©sentation de donn√©es √† mettre √† jour doit se trouver dans le body de la requ√™te (ce sont les conventions REST que nous avons fix√©es dans le cadre de ce cours).
- Si vous aviez besoin de r√©aliser une action en cas de changement du contenu d'une cellule dont **`contenteditable`** est activ√©, vous pouvez g√©rer le type d'√©v√©nement **`input`**.
  
<br/>

### Option 2 pour la mise √† jour d'info 
  
Il est aussi possible de cr√©er un nouveau composant Javascript (une page, une modal ou autre) qui reprendrait un formulaire dont les inputs contiendraient d√©j√† les valeurs existantes des propri√©t√©s d'un film. Si vous choisissez cette option, c'est √† vous de trouver l'inspiration üòâ.
